<div id="60558138" class="bookcontent"><h1>#Глава 1</h1><div id="d711e0f1" class="bookcontent"><h2>##Введение</h2>Если вам интересно системное программирование, и вы планируете заниматься разработкой высокопроизводительных и масштабируемых приложений, то вполне возможно, что в настоящий момент одним из лучших, если не единственным выбором, будет язык программирования D. <br>Несмотря на то, что в последние годы появилось большое количество новых языков программирования, призванных упростить решение современных задач, таких как Go, Rust и Swift, D, пожалуй, является наиболее перспективным и универсальным. Так, к примеру, Go показывает себя крайне хорошо для написания микро-сервисов, но при этом практически полностью не пригоден для обработки данных и расчётов. Rust – является замечательным системным языком, однако имеет крайне высокий порог вхождения и зачастую неоправданно сложен, что делает его применение в больших проектах крайне не эффективным. Swift изобилует синтаксическим сахаром и является частью весьма закрытой инфраструктуры Apple.<br>В этом плане D выгодно отличается от других игроков на рынке, так как он является по настоящему мультипарадигменным языком, что означает возможность разработки на нем как системных компонентов, так и прикладного программного обеспечения. Разумеется, вся эта мультипарадигменность имеет обратную сторону в виде определённого усложнения языка и повышения времени вхождения в него, однако обратной стороной этого является уверенность. На D вы сможете решить абсолютно любую задачу: начиная от разработки приложений для мобильных телефонов и встраиваемой микроэлектроники и заканчивая написанием движков СУБД, игр и различных высокопроизводительных веб-серверов.<br>Данная книга не является исчерпывающим руководством по языку и главным образом нацелена на начинающих. Однако представленного материала будет достаточно для написания небольших и средних приложений размером в несколько тысяч строк кода. Предыдущий опыт программирования не обязателен, однако крайне желательно хотя бы поверхностное знакомство с любым из современных языков программирования.<br>Книга так же может быть полезна для тех, кто имеет опыт разработки на других языках. В таком случае она позволит сформировать общее представление о языке D, его синтаксических конструкциях, пакетном менеджере, а так же устройстве стандартной библиотеки Phobos.<br><br><div id="83a2a51c" class="bookcontent"><h3>###Среды разработки</h3>D выгодно отличается от Java и C# тем, что разработку возможно вести практически в любом текстовом редакторе, имеющим подсветку синтаксиса. Это является следствием того, что в D отсутствует избыточный синтаксический сахар и огромное количество высокоуровневых обёрток, удаляющих программиста от понимания сути кода. Однако если вы предпочитаете использовать для разработки IDE, вы можете воспользоваться одной из существующих. Однако в целях изучения языка автор рекомендует использовать текстовые редакторы Sublime или NotePad++, т.к. они позволяют максимально полно сосредоточиться на написании кода.<br></div ><br><div id="0b7facc2" class="bookcontent"><h3>###Подготовка</h3>Кроме текстового редактора нам потребуется так же компилятор, который можно загрузить на сайте dlang.org. Компилятор включает в себя пакетный менеджер <code class="inlineCodeBlock">dub</code>, принципы работы которого мы рассмотрим в следующих главах.<br>Если вы работаете под Windows, то вы так же можете установить эмулятор командной строки <code class="inlineCodeBlock">bash</code>. Его наличие не является обязательным, однако синтаксис команд в консоли будет приведен в соответствие с его правилами. Различия будут незначительные. Так, вместо команды <code class="inlineCodeBlock">dir</code> будет использована аналогичная команда <code class="inlineCodeBlock">ls</code>.<br>Перед началом работы мы договоримся о структуре каталогов. Это позволит значительно упростить работу. Каждый проект будет содержать папку <code class="inlineCodeBlock">source</code>, в которую мы будем помещать наш код.<br></div ><br></div ><br><div id="ebe9a111" class="bookcontent"><h2>##Часть 1. Первое приложение</h2><div id="cede869f" class="bookcontent"><h3>###Приложение Hello World</h3><br>Наше первое приложение будет выглядеть следующим образом:<br><code class="language-d"><br>import std.stdio;<br>void main() <br>{<br>    writeln("Hello world!");<br>}<br></code><br>Как и все Си-подобные языки, D работает по тем же правилам. В начале вы указываете тип переменной или функции. Потом задаете ей имя. Если функция должна что-то принимать, то в круглых скобках указывается тип принимаемого значения и имя,  которое будет использовано для него внутри самой функции. Ключевое слово <code class="inlineCodeBlock">void</code> показывает, что функция ничего не возвращает. <br>Пример объявления переменной:<br><code class="language-d"><br>  int x = 5;          + Присваиваемое значение<br>   ^  ^   ^           |<br>   |  |   |           |   +Имя переменной<br>   |  |   +-----------+   |<br>   |  |                   |   + Тип переменной<br>   |  +-------------------+   |<br>   |                          |<br>   +--------------------------+<br></code><br>Пример объявления функции:<br><code class="language-d"><br>      +--------------------------------+ возвращаемый тип<br>      |<br>      |       +------------------------+ имя функции<br>      |       |<br>      |       |       +----------------+ тип принимаемых функцией данных<br>      |       |       |     <br>      |       |       |     +----------+ имя, с которым мы будем использовать принятые данные внутри функции<br>      |       |       |     |<br>      v       v       v     v<br>   string myAnswer(string name)<br>   {<br>      return "Hello, " ~ name; // Символ ~ означает склейку строк<br>   }   ^      +-------------+<br>   ^   |             ^<br>   |   |             +-----------------+ данные, которые вернет функция после своей работы. В данном случае текстовая строка<br>   |   |<br>   |   +-------------------------------+ ключевое слово, прерывающее выполнение функции и возвращающее данные<br>   |<br>   +-----------------------------------+ фигурные скобки ограничивают зону видимости. Все, что объявлено внутри них, не видно снаружи<br></code><br>Подробнее доступные типы мы рассмотрим в соответствующей главе.<br>Скопируем указанный код в текстовый файл, назовём его <code class="inlineCodeBlock">app.d</code> и поместим его в папку <code class="inlineCodeBlock">source</code>. После чего в терминале запустим команду для компиляции: <br>`&gt;dmd app.d` <br>На выходе в том же самом каталоге, в котором находится файл с исходным кодом <code class="inlineCodeBlock">app.d</code>, должен появиться скомпилированный файл приложения <code class="inlineCodeBlock">app.exe</code>. Если вы запустите его, то на экране будет выведено `Hello World`. Обратите внимание, что если вы запустите ваше первое приложение вне сессии уже открытого терминала, то оно сразу же после своего запуска автоматически завершится, и вы, скорее всего, даже не успеете увидеть результат его работы. Это происходит потому, что код доходит до конца, и в конце происходит автоматическое завершение приложения. Чтобы этого не произошло, необходимо в конец вставить функцию ожидания ввода <code class="inlineCodeBlock">readln();</code>, таким образом ваш код теперь должен выглядеть так:<br><code class="language-d"><br>import std.stdio;<br>void main() {<br>    writeln("Hello world!");<br>    readln();<br>}<br></code><br>В качестве альтернативы вы можете просто запускать скомпилированное приложение в уже открытой терминальной сессии, что позволит вам видеть в ней результаты работы вашего приложения. <br>Теперь давайте разберемся более подробно с тем, что происходит в нашем коде.<br>`import std.stdio;` выполняет импорт модуля IO (Input/Ouput), в котором определен набор функций для ввода и вывода данных. <br>`void main() { } ` является телом нашего приложения или, как его еще называют, точкой входа. Это значит, что при обращении к исполняемому файлу Операционная Система ищет в коде определённую сигнатуру, с которой и начинается выполнение приложения. <br>Концепция точки входа является базовой практически для всех языков программирования и среди компилируемых языков исключения крайне редки. Ключевое слово <code class="inlineCodeBlock">void</code> означает тип возврата в операционную систему, и согласно стандарту D <code class="inlineCodeBlock">main</code> всего должен возвращать тип <code class="inlineCodeBlock">void</code>, хотя возможен возврат и других типов, к примеру <code class="inlineCodeBlock">int</code>. <br>Именно внутри функции `main() { }` у нас происходит выполнение всех остальных функций и методов. Фигурные скобки `{ }` ограничивают зону видимости блока.<br>`writeln("Hello world!");` является функцией, которая в качестве аргументов принимает текстовую строку.<br>&gt;**Tips:** Если вы до этого не занимались серьёзно программированием, то у вас может возникнуть некоторая путаница с тем, чем метод отличается от функции. Если вы ранее не встречались с концепцией ООП, то пока не дойдёте до соответствующей главы, постарайтесь представлять методы и функции схожими понятиями. <br>Язык D имеет встроенную поддержку Unicode, а значит строка<br>`writeln("Привет Мир!");` является полностью корректной, однако если вы ее скомпилируете под Windows, то вы, скорее всего, увидите на экране кракозябры. Это происходит потому, что по умолчанию терминал Windows не работает с кодировкой Unicode и требуется переключить его вручную, введя команду: `chcp 65001`. Однако, не смотря на возможность этого, до сих пор правилом хорошего тона является использование латинского алфавита везде, где только можно, так как это позволяет избежать крайне большого количества всевозможных проблем.<br></div ><br><div id="69eadee4" class="bookcontent"><h3>###Понятие о модулях</h3>Единицей компиляции в D является модуль. Модуль представляет собой файл, содержащий в себе логически объединённые блоки кода. В данном случае об app.d можно говорить как о главном модуле приложения, содержащем точку входа. Точка входа это то с чего начинается выполнение приложение. Модули можно импортировать один в другой. Набор иерархически сгруппированных модулей называется <code class="inlineCodeBlock">пакетом</code>. Пакет представляет собой каталог на файловой системе, в котором находятся отдельные файлы-модули, объединенные в соответствии со своей функциональностью. В пакетах могут находиться вложенные пакеты, представляющие из себя папки с вложенными модулями. <br>По умолчанию D поставляется вместе с библиотекой Phobos, которая включает в себя весьма широкий набор модулей практически на все случаи жизни. Наряду с представленными в Phobos модулями программист может создавать свои собственные. Согласно правилам каждый модуль должен начинаться с заголовка, содержащего его имя (и имя пакета, если он находится внутри него).<br>Простейший пользовательский модуль выглядит следующим образом:<br><code class="language-d"><br>module foo;<br>import std.stdio;<br>void sayHello()<br>{<br>  writeln("Hello!");<br>}<br></code><br>Однако если вы попробуете скомпилировать указанный код командой:<br>`&gt; dmd foo.d`<br>то вы получите ошибку, т.к. данный модуль не содержит точки входа, и операционная система просто не сможет понять с какого места следует начать его выполнять.<br>Правилом хорошего тона является давать модулю то же самое имя, что и сохраняемому файлу. То есть если вы дали модулю заголовок `module foo;`, то будет правильно при сохранении дать ему имя <code class="inlineCodeBlock">foo.d</code>.<br>Теперь для получения доступа к функция/классам/переменным описанным в модуле <code class="inlineCodeBlock">foo.d</code> необходимо выполнить его импорт `import foo;`. Обратите внимание, что все импорты работают исключительно внутри единичного модуля. Иными словами, если вы импортируете модуль <code class="inlineCodeBlock">std.stdio</code> в модуле <code class="inlineCodeBlock">app.d</code>, но не сделаете это в модуле <code class="inlineCodeBlock">bar</code>, где, допустим, тоже нужна функция из него, то вы получите ошибку компиляции. Поэтому необходимо импортировать библиотечные функции исключительно там, где вы планируете их использовать. Если вы добавите лишний импорт там, где он не нужен (в данном случае это в <code class="inlineCodeBlock">app.d</code>), то ошибки не будет, однако делать это крайне не рекомендуется. <br>Исходный код библиотеки Phobos расположен по адресу <code class="inlineCodeBlock">dmd2/src/phobos/std</code>. Последняя часть пути <code class="inlineCodeBlock">std</code> в данном случае является пакетом, все папки в данном каталоге – подпакетами, а файлы – пакетами.<br>Набор модулей библиотеки Phobos выглядит так:<br>- string.d<br>- file.d<br>- path.d<br>- conv.d <br>- ...<br>При импорте модуля указывается каталог (имя пакета), в котором хранится модуль и через точку имя самого модуля. Таким образом, если нам потребуется выполнить импорт модуля работы с файлами, мы запишем: `import std.file;` без указания расширения <code class="inlineCodeBlock">.d</code>. По умолчанию компилятор знает, где располагаются модули библиотеки Phobos, но пользовательские пакеты и модули следует располагать внутри каталога в главном модуле (<code class="inlineCodeBlock">app.d</code>). Если нам потребуется выполнить импорт модуля <code class="inlineCodeBlock">baz</code>, расположенного в подпакете <code class="inlineCodeBlock">bar</code> пакета <code class="inlineCodeBlock">baz</code>, мы просто укажем путь до него через точку: `import foo.bar.baz;`<br> <br>По умолчанию все функции, методы и переменные являются публичными, т.е. при подключении модуля вы получаете полный доступ к его содержимому и можете вызывать определенные в нем функции, методы и переменные. Однако бывают случаи, когда модуль является достаточно большим, а вам нужно использовать из него лишь несколько функций. Импорт полного модуля может привести к конфликту имён. Эту проблему можно решить двумя способами.<br>1. Частичный импорт<br>2. Модификаторы видимости<br><div id="8858e463" class="bookcontent"><h4>####Частичный импорт</h4><br>Частичный импорт используется для функций и методов. Для частичного импорта после названия импортируемого модуля через двоеточие указывается, что именно мы хотим импортировать. К примеру, директива:<br>`import std.stdio : writeln, readln;` импортируем из модуля <code class="inlineCodeBlock">stdio</code> лишь две функции <code class="inlineCodeBlock">writeln</code> и <code class="inlineCodeBlock">readln</code>.<br></div ><br><div id="d4f26b46" class="bookcontent"><h4>####Модификаторы видимости</h4><br>Модификаторы видимости служат похожим целям, однако позволяют кроме методов задавать зоны видимости как для переменных, а так же для целых классов.<br>- <code class="inlineCodeBlock">public</code> как было написано выше, по умолчанию все содержимое модуля является публичным, однако есть возможность это указать в явном виде.<br>- <code class="inlineCodeBlock">package</code> содержимое видно только в пределах одного пакета или каталога.<br>- <code class="inlineCodeBlock">protected</code> содержимое видно только в производных классах (расположенных в других модулях).<br>- <code class="inlineCodeBlock">private</code> содержимое видно только внутри указанного модуля и к нему невозможно получить доступ извне<br>Давайте теперь попробуем написать первое приложение, состоящее из двух модулей. Создадим папку с именем <code class="inlineCodeBlock">source</code>, а в нее поместим два файла со следующим содержимым:<br>app.d:<br><code class="language-d"><br>import foo;<br>import std.stdio : writeln, readln;<br>void main()<br>{<br>  sayHello();<br>  writeln("Hello from main!");<br>  readln;<br>}<br></code><br>foo.d:<br><code class="language-d"><br>module foo;<br>import std.stdio : writeln;<br>void sayHello()<br>{<br>  writeln("Hello from module!");<br>}<br></code><br>Теперь для компиляции необходимо передать компилятору имена компилируемых файлов:<br><code class="language-d"><br>&gt;dmd app.d foo.d<br></code><br>В результате у нас получится приложение с именем <code class="inlineCodeBlock">app.exe</code>, которое после своего запуска будет выводить на консоль:<br><code class="language-d"><br>Hello from module!<br>Hello from main!<br></code><br>Обращаем ваше внимание, что в настоящий момент мы разрабатываем исключительно однопоточные приложения. Это значит, что все инструкции у нас будут выполняться последовательно и функция `writeln("Hello from main!");` будет вызвана исключительно после вызова <code class="inlineCodeBlock">sayHello();</code> не зависимо от того, насколько долго он будет выполняться.<br>Как вы могли заметить, созданная нами функция <code class="inlineCodeBlock">sayHello();</code> вызывается с пустыми скобками, а библиотечная функция <code class="inlineCodeBlock">readln;</code> без. Это происходит потому, что D позволяет опускать скобки в случае, если функция не принимает в себя никаких данных. Иными словами, абсолютно корректно будет записать как <code class="inlineCodeBlock">readln();</code>, так и <code class="inlineCodeBlock">sayHello;</code>. Однако для повышения читаемости кода имеет смысл использовать скобки.<br>D так же поддерживает концепцию UFCS (Universal Function Call Syntax). Это значит, что все функции могут быть вызваны по цепочке. То есть результат работы первой функции будет передан во вторую и т.д. Это позволяет значительно упростить чтение кода. Рассмотрим пример:<br>app.d:<br><code class="language-d"><br>import std.stdio;<br>import std.conv;<br>void main()<br>{<br>  getName.sayHello;<br>}<br>string getName()<br>{<br>  string name;<br>  write("Input username: ");<br>  name = readln;<br>  return name; //передаем данные в следующую функцию<br>}<br>void sayHello(string userName) //принимаем данные<br>{<br>  writeln("Hello, ", userName);<br>}<br></code><br>Полным эквивалентом будет вызов функции следующим образом:<br><code class="language-d"><br>...<br>void main()<br>{<br>  sayHello(getName);<br>}<br>...<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Input username: Mike<br>Hello, Mike<br></code><br>Обращаем ваше внимание, что функция <code class="inlineCodeBlock">readln;</code> получает ввод с клавиатуры всех символов. Это значит, что при нажатии Enter во ввод будет передан специальный непечатаемый символ перевода строки. В этом легко убедиться, достаточно попробовать после запуска программы не вводить данные, а нажать клавишу Enter, а в самой программе добавить вывод размера переменной:<br><code class="language-d"><br>...<br>  name = readln;<br>  writeln("Length: ", name.length);<br>  return name;<br>...<br></code><br>Результат будет следующим:<br><code class="language-d"><br>&gt; app.exe<br>Input username:<br>Length: 1<br>Hello,<br></code><br>Это может привести к проблемам, когда вы попытаетесь сравнить пользовательский ввод с заранее предопределенным значением и, не смотря на кажущуюся идентичность, код будет работать так, как если бы эти два символа были не равны. Чтобы избежать подобной ситуации для ввода с клавиатуры следует вызвать специальную функцию <code class="inlineCodeBlock">chomp</code> из состава <code class="inlineCodeBlock">std.string</code>, которая выкусывает из пользовательского ввода все непечатаемые символы. Для того, чтобы добавить ее, необходимо в начале файла <code class="inlineCodeBlock">app.d</code> добавить `import std.string;`, а так же модифицировать функцию ввода следующим образом:<br><code class="language-d"><br>  write("Input username: ");<br>  name = readln.chomp; // выкусываем из ввода непечатаемые символы<br>  writeln("Length: ", name.length);<br></code><br>&gt;**Tips: ** <code class="inlineCodeBlock">writeln()</code> после вывода  данных производит перевод курсора на строку ниже. Если это не требуется, следует использовать функцию <code class="inlineCodeBlock">write();</code><br>Теперь после ввода пустого значения наше приложение, как и ожидалось, будет показывать, что значение переменной равно нулю.<br><code class="language-d"><br>&gt; app.exe<br>Input username:<br>Length: 0<br>Hello,<br></code><br></div ><br></div ><br><div id="2d9e57d8" class="bookcontent"><h3>###Пакетный менеджер DUB</h3><br>В состав компилятора D входит пакетный менеджер <code class="inlineCodeBlock">dub</code>, который значительно упрощает управление зависимостями и позволяет гибко управлять правилами сборки приложения. В дальнейшем в целях упрощения мы будем использовать именно его.<br>Давайте посмотрим, как он работает. Для начала командой <br>`dub init` <br>создадим заголовку проекта. В результате у нас будет создан каталог <code class="inlineCodeBlock">source</code>, содержащий в себе файл <code class="inlineCodeBlock">app.d</code>, а так же файл dub.sdl, в котором описываются настройки самого проекта. Теперь, если раньше при компиляции проекта, содержащего в себе несколько модулей, нам было необходимо передать их все в качестве параметров для компилятора, то теперь достаточно поместить их в папку <code class="inlineCodeBlock">source</code>, и дальше пакетный менеджер попытается скомпилировать все содержимое этой папки.<br>Для сборки проекта достаточно вызывать команду:<br><code class="inlineCodeBlock">dub</code>, которая вначале выполнит компиляцию, а потом сразу произведет запуск скомпилированного файла. Если запуск не требуется, то можно выполнить команду `dub build`, которая произведет компиляцию без запуска.<br>&gt;**Tips: ** Все флаги компиляции D имеют свои аналоги в качестве параметров для сборки dub.<br>Теперь в случае необходимости подключения любой внешней библиотеки не нужно скачивать её отдельно и подключать. Достаточно в файле <code class="inlineCodeBlock">dub.sdl</code> указать ее как внешнюю зависимость. Если библиотека зарегистрирована на <code class="inlineCodeBlock">code.dlang.org</code>, то <code class="inlineCodeBlock">dub</code> автоматически скачает и подключит ее, и программисту будет достаточно лишь выполнить ее импорт в нужном месте.<br>Теперь попробуем подключить библиотеку для работы с <code class="inlineCodeBlock">ini</code> файлами: для этого в конец файла <code class="inlineCodeBlock">dub.sdl</code> в качестве зависимости библиотеку <code class="inlineCodeBlock">dini</code>. В результате файл настройки проекта должен выглядеть следующим образом:<br>dub.sdl:<br><code class="language-d"><br>dependency "dini" version="~&gt;2.0.0"<br></code><br>После компиляции наше приложение будет помещено в папку самого проекта. В папке <code class="inlineCodeBlock">source</code> должен располагаться исключительно код приложения и ничего больше. И в папке самого проекта приложение будет искать конфигурационный файл для чтения.<br>Подключим к файлу <code class="inlineCodeBlock">app.d</code> необходимый импорт `import dini;`, а в папке проекта создадим конфигурационный файл <code class="inlineCodeBlock">config.ini</code> со следующим содержимым:<br><code class="language-d"><br>[colors]<br>first=red<br>second=green<br>third=blue<br>[names]<br>name1=Mike<br>name2=David<br></code><br>Теперь нам останется только создать экземпляр класса [*] чтения конфигурационного файла и вызывать сам метод чтения конфига. В результате наш файл <code class="inlineCodeBlock">app.d</code> должен приобрести следующий вид:<br>App.d:<br><code class="language-d"><br>import std.stdio;<br>import dini;<br>void main()<br>{<br>  auto ini = Ini.Parse("config.ini");<br>  writeln(ini["colors"].getKey("first"));<br>  writeln(ini["names"].getKey("name1"));<br>}<br></code><br>Обратите внимание, что в настоящий момент мы нигде не проводим обработку ошибок. Это значит, что если, к примеру, конфигурационный файл или имя секции, к которой мы обращаемся, будет отсутствовать, то наше приложение упадет с ошибкой.<br>После запуска <code class="inlineCodeBlock">app.exe</code> мы увидим на экране следующие значения:<br><code class="language-d"><br>&gt;app.exe<br>red<br>Mike<br></code><br>[*] Классы и методы будут объяснены в отдельной главе.<br>&gt;**Tips: ** 1. Минимальный <code class="inlineCodeBlock">dub.sdl</code> составляет лишь одну строку и требует указания лишь имени: `name "app"` 2. Если вы хотите, чтобы скомпилированные файлы хранились не в корне проекта, а в отдельной директории <code class="inlineCodeBlock">bin</code>, добавьте в <code class="inlineCodeBlock">dub.sdl</code> следующую строку: `targetPath: "bin"`.<br></div ><br><div id="bae404e7" class="bookcontent"><h3>###Базовые правила именования</h3><br>Для упрощения чтения кода в D используется ряд соглашений по именованию.<br>1. Составные названия переменных, функций и имена экземпляров классов записываются в верблюжей нотации (camelCased). Пример: <code class="inlineCodeBlock">getUserName</code>, <code class="inlineCodeBlock">mySuperСlass</code>. Одиночные с маленькой буквы/ Пример: <code class="inlineCodeBlock">age</code><br>2. Название классов, интерфейсов, структур, шаблонов, перечислений всегда должны начинаться с заглавной буквы. Пример: <code class="inlineCodeBlock">MySuperClass</code><br>3. Если первая буква акронима заглавная, то все остальные буквы так же должны быть заглавными. Есть строчная, то все остальные буквы так же должны быть строчными. Пример: <code class="inlineCodeBlock">UTFException</code>, <code class="inlineCodeBlock">asciiChar</code>.<br></div ><br><div id="31f82215" class="bookcontent"><h3>###Комментарии</h3><br>В D используется те же правила комментирования, что и во всех Си-подобных языках. C небольшими дополнениями. <br>- одиночные строки комментируются символом <code class="inlineCodeBlock">//</code>. <br>- множественные `/* some commented code */`. <br>- если вы планируете генерировать документацию к проекту на основании исходного кода, тогда для одиночной строки используется тройной слеш <code class="inlineCodeBlock">///</code>,<br>- а для набора строк используется следующая последовательность символов: `/** some docs code */`. <br>- возможно так же использование вложенных комментариев, используя сочетание символов `/+ some commented code +/`<br>- если вы используете генератор документации, то комментарий должен располагаться строго до вызова метода или функции<br>Пример App.d:<br><code class="language-d"><br>import std.stdio;<br>import std.string;<br>/// Точка входа<br>void main()<br>{<br>  /// Эта строка не будет видна в сгенерированной документации<br>  sayHello("Mike");<br>  // Это простой комментарий, он так же не будет виден в документации<br>  foo();<br>}<br>/// Принимает имя пользователя userName с типом string<br>void sayHello(string userName) //<br>{<br>  writeln("Hello ", userName);<br>}<br>/**<br>Пример многострочного комментария.<br>Функция foo() ничего не делает.<br>*/<br>void foo()<br>{<br>}<br></code><br>Теперь запустим пакетный менеджер <code class="inlineCodeBlock">dub</code> указав, что нам требуется сгенерировать документацию по проекту. Сделаем мы это следующей командой: `dub build --build=docs`.<br>&gt;**Tips: ** Если вы хотите генерировать свежую версию документации после каждой сборки проекта, то имеет смысл добавить в <code class="inlineCodeBlock">dub.sdl</code> строку: `dflags "-Dddocs"`. Для генерации документации без помощи <code class="inlineCodeBlock">dub</code> просто вызовите компилятор с ключем <code class="inlineCodeBlock">-D</code> и передайте ему список файлов, которые следует обработать. Пример: `dmd -D app.d foo.d`.<br>Для того, чтобы лучше ориентироваться в коде рекомендуется в комментариях использовать следующие теги:<br>- <code class="inlineCodeBlock">TODO</code> необходмо реализовать функционал<br>- <code class="inlineCodeBlock">FIXME</code> необходимо провести исправления кода<br>- <code class="inlineCodeBlock">BUG</code> фрагмент кода содержит ошибку<br>- <code class="inlineCodeBlock">HACK</code> код содержит грязный хак<br>- <code class="inlineCodeBlock">NOTE</code> примечание к коду<br>Пример: <br><code class="language-d"><br>void foo() //NOTE: это просто пример функции<br>{<br>// TODO: необходимо реализовать тело функции<br>}<br></code><br>В больших проектах по соглашению команды данный набор тегов может быть расширен.<br><br></div ><br></div ><br><div id="598cbf77" class="bookcontent"><h2>##Система типов в D</h2><br>D является строго типизированным языком. Это позволяет не только избежать огромного количества ошибок, которые порождает динамическая типизация, но и на этапе компиляции проводить целый ряд оптимизаций, позволяющих значительно поднять скорость работы приложения. В D все типы переменных инициализируются значением по умолчанию, это облегчает поиск возможных ошибок.<br>D является регистрозависимым языком, так что с точки зрения компилятора переменные <code class="inlineCodeBlock">myVar</code> и <code class="inlineCodeBlock">myvar</code> имеют два разных имени. Имена переменных могут начинаться с подчеркивания и содержать в себе цифры (но не начинаться с них).<br>Ниже приведена таблица с имеющимися в языке D типами: (fixme).<br>Как уже было сказано выше, статическая типизация позволяет провести ряд оптимизаций по скорости и потреблению памяти. Но в некоторых случаях, когда производительность кода крайне важна, мы можем дополнительно указать компилятору, что то или иное значение является константой. Это позволяет провести дополнительные оптимизации.<br><code class="language-d"><br>int a = 1; // объявляем переменную a с типом int и присваиваем ей в качестве значения число 1<br>immutable int b = 2; // объявляем неизменяемую переменную b и присваиваем ей число 2<br></code><br>D так же поддерживает автоматическое определение типа переменной на основании присваиваемого ей значения. Для этих целей используется ключевое слово <code class="inlineCodeBlock">auto</code>.<br><code class="language-d"><br>auto c = 3;<br>auto d = "my string";<br></code><br>В данном случае компилятор сам в состоянии определить, какой тип имеют данные. Однако, злоупотреблять автоматической типизацией крайне не рекомендуется. Она значительно усложняет поддержку кода т.к. программисту на глаз становится практически невозможно понять какой тип данных скрывается за ключевым словом <code class="inlineCodeBlock">auto</code>. <br>Несколько слов нужно сказать о типе <code class="inlineCodeBlock">size_t</code>. Долгое время размер <code class="inlineCodeBlock">int</code> совпадал с битностью микропроцессора т.е. во время господства 32-битных систем размер <code class="inlineCodeBlock">int</code> был де-факто равен 32 битам. Однако с появлением 64-битных систем появилась проблема, что нужно или расширять размеры <code class="inlineCodeBlock">int</code> или вводить новый тип. Для целого ряда операций было достаточно типа <code class="inlineCodeBlock">int</code> равного 32 битам и так же очень не хотелось ломать обратную совместимость. Поэтому был введен новый тип под названием <code class="inlineCodeBlock">size_t</code> который был привязан уже не к фиксированному числу, а к максимально возможному целочисленному типу для данной платформы. Если компилятор будет запущен на 128 битном процессоре, <code class="inlineCodeBlock">size_t</code> будет равен 128 битам.<br><div id="31e4f0dd" class="bookcontent"><h4>####Строковые типы</h4>Следует отметить, что в таблице приведены только фундаментальные типы. Как вы могли заметить, в ней отсутствует, к примеру, тип <code class="inlineCodeBlock">string</code>. Это происходит по той причине, что <code class="inlineCodeBlock">string</code> является лишь обёрткой над массивом неизменных символов (<code class="inlineCodeBlock">immutable(char)[]</code>). Неизменность символов означает, что вы не можете изменить отдельный символ в строке:<br><code class="language-d"><br>string str = "big";<br>str[1] = 'a';<br></code><br>Компилятор выдаст ошибку:<br><code class="language-d"><br>Error: cannot modify immutable expression str[1]<br></code><br>Строки в D представляют из себя структуру следующего вида:<br><code class="language-d"><br>struct {<br>  size_t length;<br>  &lt;type&gt;* ptr;<br>}<br></code><br>Где <code class="inlineCodeBlock">length</code> - это длина, а ptr - указатель на начало строки. Таким образом, у каждой строки есть длина и указатель на первый элемент. Давайте проверим это:<br><code class="language-d"><br>  string str = "abc";<br>  writeln(str);<br>  writeln(str.length); // размер строки<br>  writeln(str.ptr); // адрес первого символа<br>  writeln(*str.ptr); // получаем значение переменной по адресу<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>abc<br>3<br>42E080<br>a<br></code><br>Первый элемент строки <code class="inlineCodeBlock">abc</code> - это символ <code class="inlineCodeBlock">a</code>, расположенный по адресу 42E080.<br>Как было сказано выше, строка - это набор неизменяемых `char []`. Это значит, что большинство операций, приводящих к изменению размера строки, будут происходить через дополнительное аллоцирование. То есть при изменении строки будет создаваться ее измененная копия. Главная причина подобного решения кроется в том, что если бы строки были изменяемыми, то это породило бы огромное количество ошибок в многопоточных приложения, когда несколько потоков обращались бы к одной и той же строке, меняя ее произвольным образом. <br>Давайте теперь попробуем изменить строку и посмотреть, как изменится значение указателя на первый символ.<br><code class="language-d"><br>  string str = "abc";<br>  writeln(str.ptr);<br>  str = "def";<br>  writeln(str.ptr);<br></code><br>Вывод:<br><code class="language-d"><br>&gt; app.exe<br>42E080<br>42E084<br></code><br>Как видим, адрес 42E080 увеличился на 4 бита и стал равен 42E084. Дело в том, что для доступа к огромному количеству уже написанных библиотек на Си разработчики D были вынуждены добавить некоторые особенности языка Си. Хотя в D строки являются структурой, но в конце каждой из записей дописывается <code class="inlineCodeBlock">0</code>, который в Си означает символ конца строки. Однако компилятор все это дело скрывает и для программиста на D строка - это строка.<br>Строки в D хранятся в виде массива известной длины. Это позволяет не только избежать целого ряда ошибок, которые вызывают null-терминированные строки в C/C++, но и позволяет делать такую полезную вещь, как срезы. Срезы не приводят к дополнительной аллокации, т.к. представляют из себя лишь манипуляцию над указателями на начало и конец строки.<br>Тот факт, что строки представляют из себя структуры, имеющие размер и указатель на первый элемент, очень удобен тем, что появляется возможность делать над строками такой тип операции, как срезы - т.е. брать произвольное количество символов как с начала, так и с конца строки. <br>Предположим, нам требуется выбрать из строки символы с 2 по 5 (не забываем, что это мы считаем с единицы, а компилятор считает с нуля). Для этого мы напишем следующий код:<br><code class="language-d"><br>string str = "abcdefg";<br>string newstr = str[1..4];<br>writeln(newstr);<br></code><br>Результат работы кода будет следующим:<br><code class="language-d"><br>&gt; app.exe<br>bcd<br></code><br>(checkme) В результате будет создана новая переменная, содержащая указатель на структуру, ссылающиеся на исходную строку.<br>D из коробки поддерживает Unicode. Как вы знаете, в Unicode разные кодовые страницы разных алфавитов могут иметь разную длину.  Кроме того, некоторые символы могут иметь переменную длину. Т.е. к примеру, в испанском слове сон <code class="inlineCodeBlock">soñar</code> используется диакретическая литера <code class="inlineCodeBlock">ñ</code>, которая кодируется как два символа: первым символом является английская буква n, вторым - надстрочный диакретический знак. Поэтому для хранения символов в кодировке Unicode следует использовать правильный тип.<br>В D предусмотрены три символьных типа:<br>- <code class="inlineCodeBlock">char</code> размером 8 бит<br>- <code class="inlineCodeBlock">wchar</code> размером 16 бит<br>- <code class="inlineCodeBlock">dhar</code> размером 32 бит<br>Строки так же как отдельные символы имеют версии для различных Unicode кодировок. Так, строка <code class="inlineCodeBlock">string</code> предназначена для хранения символов, равных 8 битам, <code class="inlineCodeBlock">wstring</code> - 16, а <code class="inlineCodeBlock">dstring</code> - 32. Если вы используете неправильный тип, к примеру, попытаетесь записать в переменную с типом <code class="inlineCodeBlock">string</code> символы, часть из которых кодируется 16 битами, то ошибки не произойдет. Однако если вы попытаетесь проверить размер данной переменной, то получите некорректный результат.<br>Пример:<br><code class="language-d"><br>  string str = "soñar";<br>  writeln(str.length);<br></code><br>Результат:<br><code class="language-d"><br>6<br></code><br>В то время как в слове у нас всего пять букв. Однако если мы используем тип <code class="inlineCodeBlock">wstring</code>, то получим корректный результат.<br>Пример:<br><code class="language-d"><br>  wstring str = "soñar";<br>  writeln(str.length);<br></code><br>Результат:<br><code class="language-d"><br>5<br></code><br></div ><br><div id="0a2aa1be" class="bookcontent"><h3>###Форматирование строк</h3><br>Средства для форматирования строк в D крайне богаты, однако в повседневной жизни вам потребуется не так уж много. Для склейки строк у нас используется символ <code class="inlineCodeBlock">~</code>. <br>Пример:<br><code class="language-d"><br>  string str = "aaa" ~ "bbb" ~ "ccc";<br>  writeln(str);<br></code><br>Результат:<br><code class="language-d"><br>aaabbbccc<br></code>  <br>Данные типа <code class="inlineCodeBlock">char</code> всегда берутся в одинарные кавычки, тип <code class="inlineCodeBlock">string</code> - всегда в двойные.<br>Пример:<br><code class="language-d"><br>  char foo = 'a'; // одиночный символ<br>  string bar = "b"; // один или более символов<br></code><br>Во многих языках программирования большую проблему составляет вывод строк, содержащих спецсимволы, которые в некоторых случаях могут восприниматься как управляющие команды. К примеру, <code class="inlineCodeBlock">\n</code> вызывает перевод текстового курсора на новую строку. Но как быть, если подобное сочетание встречается в обычной строке? К примеру, в пути: `Press yes\now for continue` или, к примеру, нам потребовалось бы вывести строку, содержащую в себе кавычки.<br>app.d:<br><code class="language-d"><br>void main()<br>{<br>  string str = "Press yes\now for continue";<br>  writeln(str);<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Press yes<br>ow for continue<br></code><br>Раньше проблему было принято решать экранированием всех проблемных символов, однако это значительно усложняло чтение кода, особенно в случае написания SQL запросов и путей в Windows, когда приходилось экранировать все кавычки и пути. Однако в D этой проблемы можно избежать, обрамляя подобные символы в строке символом апострофа (не путать с одиночной кавычкой):<br><code class="language-d"><br>string str = `Press yes\now for continue`;<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Press yes\now for continue<br></code><br>Еще одним способом представления строки является использование специальной литеры <code class="inlineCodeBlock">q</code>. Эта литера, поставленная перед строкой, содержащей различные скобки, апострофы, кавычки, управляющие последовательности и т.д., позволяет представить их все в неизменном виде. Правила использования литеры <code class="inlineCodeBlock">q</code> крайне простые. Вслед за ней должен идти один из следующих открывающих и закрывающих последовательность символом: `{ }`, `[ ]`, `( )`, `&lt; &gt;`. А между ними может располагаться любая строка. <br>Пример:<br><code class="language-d"><br>  string str = q"&lt;It's \0 \n&gt;";<br>  writeln(str);<br></code><br>Выведет:<br><code class="language-d"><br>&gt; app.exe<br>It's \0 \n<br></code><br>Пример:<br><code class="language-d"><br>  string str = q"[&lt;Test&gt;]";<br>  writeln(str);<br></code><br>Выведет:<br><code class="language-d"><br>&gt; app.exe<br>&lt;Test&gt;<br></code><br>Кроме этого при помощи все той же литеры <code class="inlineCodeBlock">q</code>, только с несколько иным синтаксисом, можно помещать в переменную целые куски кода, которые впоследствии можно использовать во время компиляции. На этот раз строка обязана открываться с символов <code class="inlineCodeBlock">q{</code> и закрываться символом <code class="inlineCodeBlock">}</code>.<br>Главное правило как вы уже поняли такое, что для открывающей и закрывающей последовательности строки нужно использовать такой символ, который бы не встречался в самой строке и не воспринимался бы как ее завершение. Т.е. запись: `string str = q"[&lt;Te]st&gt;]";` является некорректной, т.к. в середине строки встречается закрывающий символ. Однако если перед ним будет использоваться открывающий символ, то строка будет полностью корректной: `string str = q"[&lt;T[e]st&gt;]";`<br>До этого в примерах использовали практически исключительно вывод при помощи функции <code class="inlineCodeBlock">writeln</code>, которая после вывода строки совершает перевод текстового курсора на строку ниже. Если перевод не требуется, то следует использовать простую функцию <code class="inlineCodeBlock">write</code>, однако в случае необходимости совершить перевод строки нам ничего не мешает внутри нее использовать все ту же служебную последовательность символов, указанную выше: <code class="inlineCodeBlock">\n</code>.<br>В некоторых случаях может потребовать расширенное форматирование строки так, чтобы можно было в специально отведённые места подставить значение переменных. Для этого используется функция <code class="inlineCodeBlock">writef</code> и <code class="inlineCodeBlock">writefln</code> соответственно. <code class="inlineCodeBlock">f</code> от слова <code class="inlineCodeBlock">format</code>.<br>Для каждого типа данных используется свой подстановочный символ. Для подстановки строкового типа <code class="inlineCodeBlock">%s</code>, для целого числа <code class="inlineCodeBlock">%d</code>, для числа с плавающей точкой <code class="inlineCodeBlock">%g</code>. Полный список подстановочных символов крайне велик и его всегда можно посмотреть в официальной документации.<br>app.d:<br><code class="language-d"><br>import std.stdio;<br>import std.string;<br>void main()<br>{<br>  string name = "Mike";<br>  int age = 20;<br>  float height = 184.5;<br>  writefln("Hi, %s you are %d, you height is %g", name, age, height);<br>}<br></code><br>Вывод:<br><code class="language-d"><br>&gt; app.exe<br>Hi, Mike you are 20, you height is 184.5<br></code><br>Чисто технически ничто не запрещает вам везде использовать строковый подстановочный символ <code class="inlineCodeBlock">%s</code>. <code class="inlineCodeBlock">writeln</code>, который в большинстве случаев сможет корректно привести тот или иной тип к строковому и вывести его. Однако в случаях, когда вам нужно, чтобы, к примеру, тип с плавающей точкой был выведен до определённого количества знаков после точки, тогда рекомендуется указывать его тип в явном виде.<br>Обратите внимание, что только функции семейства <code class="inlineCodeBlock">write</code> делают подстановку символов за вас. Если вам требуется передать строку с подстановками в другую функцию, то следует вызвать функцию <code class="inlineCodeBlock">format</code>, форматирующую строку с учетом подстановочных переменных.<br>Пример:<br><code class="language-d"><br>...<br>string mylogin = "Mike";<br>string mypassword = "superpass";<br>string city = "London";<br>string sqlinsert = format(`INSERT INTO usersshapes (login, password, cite) VALUES ('%s', '%s', '%s') `, mylogin, mypassword, mycity);<br>stmt.executeUpdate(sqlinsert);<br></code><br></div ><br><div id="3dfefe66" class="bookcontent"><h3>###Формат представления данных в оперативной памяти</h3><br>В современных операционных системах все приложения изолированы друг от друга с помощью так называемого механизма виртуальной памяти. Операционная система через специальные таблицы трансляции заставляет каждое приложение думать, что ему доступно все адресной пространство. Этот механизм был введен специально, т.к. иначе бы в многозадачной операционной системе приложения могли легко повредить память друг друга. Чисто технически существуют механизмы, которые позволяют приложениям обращаться к адресному пространству друг друга, но в данной книге мы их рассматривать не будем.<br>Говоря про память нельзя не затронуть такую важную часть, как указатели. Указатели представляют собой специальные переменные, которые позволяют обращаться к участкам памяти. Объявляются они так же как переменные, но перед их именем ставится звездочка. Чтобы визуально отличать указатели от других переменных обычно к их названию добавляют буквы <code class="inlineCodeBlock">ptr</code> от слова <code class="inlineCodeBlock">pointer</code>. Тип, используемый при объявлении указателя, в точности должен соответствовать типу переменной, адрес которой мы присваиваем указателю.<br><code class="language-d"><br>int *x_ptr; // указатель на целое<br>string *str_ptr; // указатель на строку<br></code><br>Для получения адреса переменной используется символ асперсанда <code class="inlineCodeBlock">&</code>. Не следует путать оператор взятия адреса со ссылкой на некоторое значение, которое так же визуально отображается символом <code class="inlineCodeBlock">&</code>.<br>Как только мы взяли адрес переменной и поместили его в указатель, мы можем работать с указателем точно так же, как если бы он был значением переменной. Для того, чтобы превратить указатель в значение, необходимо выполнить операцию разыменования (перед указателем поставить звездочку).<br><code class="language-d"><br>  int x = 2;<br>  int *x_ptr = &x; // заносим в указатель адрес переменной 2<br>  writeln(x_ptr); // выводим адрес, по которому лежит переменная 2<br>  writeln(*x_ptr); // преобразуем адрес в значение 2<br>  int z = *x_ptr+2; // то же самое, что x + 2<br>  writeln(z);<br></code><br>Ссылки и указатели часто используются при обработке данных, которые нет смысла передавать в функцию, т.к. операция копирования данных потребует не только дополнительные затраты по времени, но и по памяти.<br>Рассмотрим следующий код:<br><code class="language-d"><br>void main() <br>{<br>  int x = 2;<br>  calc(x); <br>  writeln(x);<br>}<br>void calc(int x)<br>{<br>  x = x+2;<br>}<br></code><br>Как несложно догадаться данный код выведет число <code class="inlineCodeBlock">2</code>, т.к. функция `calc(int x)` принимает копию значения и работает уже с ним. Но как быть, если требуется изменить значение исходной переменной? Вот тут как раз оказываются полезны ссылки с указателями. Давайте исправим код так, чтобы в функцию мы передавали указатель на <code class="inlineCodeBlock">x</code> и выполняли бы уже операции непосредственно с ним.<br><code class="language-d"><br>void main() <br>{<br>  int x = 2;<br>  calc(&x);<br>  writeln(x);<br>}<br>void calc(int *x) // тут происходит: *x = &x<br>{<br>  *x = *x+2; // к разыменованному значению указателя прибавляет 2 и кладем в него обратно<br>}<br></code><br>В результате строка <code class="inlineCodeBlock">writeln(x);</code> выведет значение <code class="inlineCodeBlock">4</code>.<br><br>Хотя  с указателями можно работать точно так же, как с простыми переменными, их следует использовать с крайней осторожностью и только в том случае, если вы очень хорошо понимаете, что делаете. Неосторожное их использование может породить огромное количество ошибок обращения по неправильным адресам. Так, к примеру, вы можете удалить объект, на который был нацелен указатель, а указатель продолжит указывать на область памяти, где ранее располагались данные. В случае, когда программа записывает данные в память, используя такой указатель, данные могут незаметно разрушаться, что приводит к тонким ошибкам, которые очень трудно найти.<br>В большинстве случаев для того, чтобы работать с оригинальными данными, а не с их копией, достаточно использовать ключевое слово <code class="inlineCodeBlock">ref</code>. <code class="inlineCodeBlock">ref</code> говорит о том, что при изменении <code class="inlineCodeBlock">ref</code> переменной будет изменена и переменная, на которую та указывает.<br><br><code class="language-d"><br>void main()<br>{<br>  int x = 2;<br>  calc(x);<br>  writeln(x); // x теперь равно 4<br>}<br>void calc(ref int x)<br>{<br>  x = x+2;<br>}<br></code><br>Результат:<br><code class="language-d"><br>4<br></code><br><br></div ><br><div id="467a7515" class="bookcontent"><h3>### Массивы</h3><br>D поддерживает следующие типы массивов: статические, динамические, ассоциативные и строки, рассмотренные выше. Реализацию многомерных массивов мы затрагивать не будем.<br>Массив для себя проще всего представлять набором из элементов одинакового типа, у которых есть размер (<code class="inlineCodeBlock">length</code>) и указатель (<code class="inlineCodeBlock">ptr</code>) на первый элемент.<br>Строго говоря, строка является частным случаем массива. Упрощенно массив можно представить следующим образом:<br><code class="language-d"><br>struct {<br>  size_t length;<br>  T* ptr;<br>}<br></code><br>Где <code class="inlineCodeBlock">T*</code> будет представлять из себя некий тип данных, который в случае со строкой был `char []`. Однако все остальные типы массивов по структуре будут несколько отличаться друг от друга.<br><div id="f3069a9d" class="bookcontent"><h4>####Статические массивы</h4><br>При объявлении статического массива программист заранее должен указать его размерность:<br><code class="language-d"><br>  int [5] x; <br>  x[4] = 3; // присваиваем пятому элементу (4-ому, если считать от нуля) число 3<br>  writeln(x);<br></code><br>Результат: <br><code class="language-d"><br>&gt; app.exe<br>[0, 0, 0, 0, 3]<br></code><br>Если вы попробуете обратиться в статическом массиве за его пределы, то компилятор выдаст вам ошибку.<br><code class="language-d"><br>  int [5] x; <br>  x[6] = 3;<br></code><br><code class="language-d"><br>Error: array index 6 is out of bounds x[0 .. 5]<br></code><br>Перечень свойств, доступных для статических массивов:<br>- <code class="inlineCodeBlock">.init</code> значение по умолчанию<br>- <code class="inlineCodeBlock">.sizeof</code> размер массива в байтах (количество элементов, умноженное на их размер)<br>- <code class="inlineCodeBlock">.length</code> количество элементов<br>- <code class="inlineCodeBlock">.ptr</code> указатель на первый элемент<br>- <code class="inlineCodeBlock">.dup</code> создать динамическую копию текущего массива<br>- <code class="inlineCodeBlock">.idup</code> создать динамическую копию текущего массива с типом immutable<br>Рассмотрим некоторые свойства.<br>init: <br><code class="language-d"><br>  int [5] x = [5,5,4,1,2]; <br>  writeln(x.init);<br>  double [3] y = [1.4,25.01, 34.801]; <br>  writeln(y.init);<br></code><br>Результат:<br><code class="language-d"><br>[0, 0, 0, 0, 0]<br>[nan, nan, nan]<br></code><br><br>length:<br><code class="language-d"><br>  int [5] x = [5,5,4,1,2]; <br>  writeln(x.length);<br>  double [3] y = [1.4, 25.01, 34.801]; <br>  writeln(y.length);<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>5<br>3<br></code><br><br><code class="language-d"><br>  int [3] x = [1,2,3];<br>  int [] y = x.dup;<br>  y ~=4;<br>  writeln(y);<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>[1, 2, 3, 4]<br></code><br>&gt;**Tips: ** Для выполнения различных манипуляций над массивами, таких как: сортировка, вставка элементов и т.д. используйте библиотеку <code class="inlineCodeBlock">std.algorithm</code><br></div ><br><div id="f89b0eb0" class="bookcontent"><h4>####Динамические массивы</h4><br>В отличие от статических массивов размер динамических на этапе компиляции не известен и может меняться во время выполнения программы, и при обращении к свойству <code class="inlineCodeBlock">length</code> мы всегда сможем получить точное количество элементов в массиве. В остальном динамические массивы имеют точно такой же набор свойств с тем лишь исключением, что свойство <code class="inlineCodeBlock">.init</code> для них будет всегда равно <code class="inlineCodeBlock">null</code>. Следующий пример показывает расширение динамического массива.<br><code class="language-d"><br>  int [3] x = [1,2,3];<br>  int [] y = x.dup;<br>  y ~=4;<br>  writeln(y);<br></code><br>Операция <code class="inlineCodeBlock">~=</code> означает добавление элемента<br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>[1, 2, 3, 4]<br></code><br>Так же как и строки массивы, имеющие один тип, можно склеивать:<br><code class="language-d"><br>  int [] a = [1,2,3];<br>  int [] b = [4,5,6];<br>  int [] z;<br>  z = a ~ b;<br>  writeln(z);<br></code><br>Результат:<br><code class="language-d"><br>[1, 2, 3, 4, 5, 6]<br></code><br><br></div ><br><div id="af82fded" class="bookcontent"><h4>####Ассоциативные массивы</h4>В разных языках этот термин называют по-разному. В D под ассоциативными массивами понимают связку ключ-значение. Ключом и значением может быть любой тип. <br>После объявления формат записи значений в ассоциативный массив выглядит следующим образом:<br>`aa[key] = value`<br>Объявим ассоциативный массив с ключом в типа <code class="inlineCodeBlock">int</code> и значением типа <code class="inlineCodeBlock">string</code>:<br><code class="language-d"><br>  string [int] aa;<br>  aa[1] = "Mike";<br>  aa[2] = "Jow";<br>  aa[3] = "David";<br>  writeln(aa);<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>[3:"David", 2:"Jow", 1:"Mike"]<br></code><br>Ключом и значением может быть абсолютно любой тип данных. Давайте теперь сделаем, чтобы ключом и значением были строки:<br><code class="language-d"><br>  string [string] aa;<br>  aa["one"] = "Mike";<br>  aa["two"] = "Jow";<br>  aa["three"] = "David";<br>  writeln(aa);<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>["three":"David", "two":"Jow", "one":"Mike"]<br></code><br>Значения в ассоциативных массивах можно перезаписывать:<br><code class="language-d"><br>aa["one"] = "Piter";<br></code><br>Код выше изменит значение для ключа <code class="inlineCodeBlock">one</code> на имя <code class="inlineCodeBlock">Piter</code>. Если вы попытаетесь обратиться к несуществующему ключу, будет выкинуто исключение:<br><code class="language-d"><br>...<br>string str = aa["fourth"]; // пытаемся получить значение из несуществующего ключа<br>...<br></code><br>Удаление элементов производится с помощью функции <code class="inlineCodeBlock">array_name.remove(key)</code>.<br>Пример:<br><code class="language-d"><br>  string [string] aa;<br>  aa["one"] = "Mike";<br>  aa["two"] = "Jow";<br>  aa["three"] = "David";<br>  writeln(aa);<br>  aa.remove("one"); // удаляем значение с ключом "one"<br>  writeln(aa);<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>["three":"David", "two":"Jow", "one":"Mike"]<br>["three":"David", "two":"Jow"]<br></code><br>Ошибка: `core.exception.RangeError@app.d(48): Range violation`. Элемент, к которому вы пытаетесь, не существует.<br>Набор свойств у ассоциативных массивов значительно отличается от статических и динамических. Так, для них доступны следующие свойства:<br>- <code class="inlineCodeBlock">.length</code> количество элементов<br>- <code class="inlineCodeBlock">.keys</code> возвращает динамический массив, содержащий набор ключей<br>- <code class="inlineCodeBlock">.values</code> возвращает динамический массив, содержащий набор значений<br>- <code class="inlineCodeBlock">.byKey()</code> возвращает ленивый диапазон ключей без дополнительного выделения памяти<br>- <code class="inlineCodeBlock">.byValue()</code> возвращает ленивый диапазон значений без дополнительного выделения памяти<br>- <code class="inlineCodeBlock">.byKeyValue()</code> возвращает ленивый диапазон ключей и значений ассоциативного массива, к которым впоследствии можно обратиться как <code class="inlineCodeBlock">.key</code> и <code class="inlineCodeBlock">.value</code> без дополнительного выделения памяти<br>- <code class="inlineCodeBlock">.rehash</code> переупорядочить элементы для повышения скорости. Полезно когда значения часто добавлялись и удалялись<br>- <code class="inlineCodeBlock">.clear</code> очистить ассоциативный массив от содержимого. Для того чтобы освободить занятую память, необходимо выполнить <code class="inlineCodeBlock">.rehash</code><br>- `.get(Key key, lazy Value defVal)` проверяет, содержит ли массив указанный ключ, если нет, то возвращается значение по умолчанию<br>Давайте рассмотрим переборку ассоциативного массива по ключу и значению.<br><code class="language-d"><br>  string [string] aa;<br>  aa["one"] = "Mike";<br>  aa["two"] = "Jow";<br>  aa["three"] = "David";<br>  foreach(element; aa.byKey())<br>  {<br>    writeln("-&gt; ", element);<br>  }<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>-&gt; three<br>-&gt; two<br>-&gt; one<br></code><br>Если `foreach(element; aa.keys)` мы заменим на `foreach(element; aa.byValue())`, то на выходе получим не ключи, а значения.<br>Результат:<br><code class="language-d"><br>-&gt; David<br>-&gt; Jow<br>-&gt; Mike<br></code><br>Для проверки, существует ли ключ в ассоциативном массиве, используется оператор <code class="inlineCodeBlock">in</code>. Давайте посмотрим, как он работает:<br><code class="language-d"><br>  string [string] aa;<br>  aa["one"] = "Mike";<br>  aa["two"] = "Jow";<br>  aa["three"] = "David";<br>  if("somekey" in aa) // "somekey" в списке ключей у нас отсутствует<br>  {<br>    writeln("somekey is exists in array");<br>  }<br>  else<br>  {<br>    writeln("somekey do not exists in array"); // поэтому срабатывает этот блок<br>  }<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>somekey do not exists in array<br></code><br>В некоторых ситуациях бывает нужно проверить, существует ли ключ в массиве и если нет, то вернуть какое-то другое предопределенное значение. Для этого используется свойство ассоциативного массива <code class="inlineCodeBlock">.get()</code>. <br>Давайте проверим теперь, как работает свойство <code class="inlineCodeBlock">get()</code>.<br><code class="language-d"><br>  string [string] aa;<br>  aa["one"] = "Mike";<br>  aa["two"] = "Jow";<br>  aa["three"] = "David";<br>  string str = aa.get("two", "nothing"); // вернет "Jow"<br>  writeln(str);<br>  string str2 = aa.get("somekey", "nothing"); // вернет значение по-умолчанию "nothing"<br>  writeln(str2);<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Jow<br>nothing<br></code><br>Ключ "two" существует , и мы возвращаем его значение в переменную <code class="inlineCodeBlock">str</code>. Ключ был не найден "somekey", поэтому переменная <code class="inlineCodeBlock">str2</code> получила указанное значение по умолчанию "nothing".<br></div ><br></div ><br></div ><br><div id="538585c4" class="bookcontent"><h2>##Операторы языка</h2><br><div id="548a5d77" class="bookcontent"><h3>###Логические операторы</h3><br>Выше в тексте вы уже использовали один из самых логических операторов - символ равенства <code class="inlineCodeBlock">=</code>, с помощью которого вы выполняли присвоения переменной определенного значения. Давайте рассмотрим, какие логические операторы существуют еще.<br><code class="inlineCodeBlock">==</code> проверка на равенство. Если левая и правая часть совпадают, то будет возвращено значение <code class="inlineCodeBlock">true</code>, в противном случае будет возвращено <code class="inlineCodeBlock">false</code>.<br><code class="inlineCodeBlock">!=</code> проверка на неравенство. Если левая и правая части не совпадают, то будет возвращено значение <code class="inlineCodeBlock">false</code>, в противном случае будет возвращено <code class="inlineCodeBlock">true</code>.<br><code class="inlineCodeBlock">||</code> логическое <code class="inlineCodeBlock">или</code>. Если хотя бы одно условие истина, то будет возвращено <code class="inlineCodeBlock">true</code>, если нет, то <code class="inlineCodeBlock">false</code><br><code class="inlineCodeBlock">&&</code> логическое <code class="inlineCodeBlock">и</code>. Если все условия истинны, то будет возвращено <code class="inlineCodeBlock">true</code>, если нет, то <code class="inlineCodeBlock">false</code><br><code class="inlineCodeBlock">&gt;</code>, <code class="inlineCodeBlock">&lt;</code>, <code class="inlineCodeBlock">&gt;=</code>, <code class="inlineCodeBlock">&lt;=</code>. Операторы позволяют оценивать числовые значения и возвращать <code class="inlineCodeBlock">true</code> или <code class="inlineCodeBlock">false</code> в зависимости от результата проверки.<br>Операторы можно группировать между собой и записывать сложные выражения. Пример:<br><code class="language-d"><br>  int x = 2;<br>  int y = 7;<br>if(x&lt;3 && y&gt;=5) // если <code class="inlineCodeBlock">x</code> меньше трех И <code class="inlineCodeBlock">y</code> больше или равен 5<br>  writeln("x is less than 3 and y is greater than 5");<br>else<br>  writeln("expression is false");<br></code><br> Результат:<br><code class="language-d"><br> &gt; app.exe<br>x is less than 3 and y is greater than 5<br></code><br>Для того, чтобы проверить булевые значения, достаточно просто записать их внутри оператора <code class="inlineCodeBlock">if</code>.<br>Пример:<br><code class="language-d"><br>  bool myValue = true;<br>  if(myValue) // если myValue истина<br>    writeln("Block A");<br>  else // если myValue ложь<br>    writeln("Block B");<br></code><br>Результат:    <br><code class="language-d"><br>&gt; app.exe<br>Block A<br></code><br>Если требуется выполнить обратное действие -- проверить значение на ложность, то в блоке <code class="inlineCodeBlock">if</code> перед его названием требуется поставить восклицательный знак.<br>Пример:<br><code class="language-d"><br>  bool myValue = true;<br>  if(!myValue) // если myValue истина<br>    writeln("Block A");<br>  else // если myValue ложь<br>    writeln("Block B");<br></code><br>Результат:    <br><code class="language-d"><br>&gt; app.exe<br>Block B<br></code><br></div ><br><div id="12ef3b51" class="bookcontent"><h3>###Операторы if и else</h3><br>Операторы <code class="inlineCodeBlock">if</code> и <code class="inlineCodeBlock">else</code> позволяют проводить оценку условий и принимать решения о том, какая из ветвей кода должна выполняться.<br><code class="language-d"><br>import std.stdio;<br>import std.string;<br>void main()<br>{<br>  int x = 2;<br>  int y = 5;<br>  if(x&lt;5)<br>    writeln("x is less than y");<br>  else<br>    writeln("x is greater than y"); <br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>x is less than y<br></code><br>Форма записи блоков <code class="inlineCodeBlock">if</code> и <code class="inlineCodeBlock">else</code> без фигурных скобок, как в примере выше, является краткой. Если после условия <code class="inlineCodeBlock">if</code> или <code class="inlineCodeBlock">else</code> выполнить не единичное выражение, а блок кода, тогда необходимо обернуть его в фигурные скобки `{ ... }`.<br>Пример:<br><code class="language-d"><br>if(a&lt;b)<br>{<br>  writeln("Block A"); // вызов первой функции<br>  foo(); // вызов еще одной функции <br>}<br>else<br>{<br>  writeln("Block B"); // вызов первой функции<br>  bar(); // вызов еще одной функции <br>}<br></code><br></div ><br></div ><br><div id="74d322ff" class="bookcontent"><h2>##Операторы циклов</h2><div id="04ea51b7" class="bookcontent"><h3>###Цикл for</h3>Тело цикла <code class="inlineCodeBlock">for</code> будет выполняться до тех пор, пока условие будет истинно (т. е. true). Цикл <code class="inlineCodeBlock">for</code> всегда принимает три параметра: 1. стартовая переменная 2. условие работы 3. действие над стартовой переменной. Пример:<br><code class="language-d"><br>void main()<br>{ <br>  int x; <br>  for(x=0; x&lt;5; x++) // стартовое значение; условие работы; действие над стартовой переменной<br>  {<br>    writeln(x);<br>  }<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>1<br>2<br>3<br>4<br></code><br></div ><br><div id="bf7df8a3" class="bookcontent"><h3>###Цикл foreach</h3>Большинство современных программистов предпочитают использовать более высокоуровневый итератор циклов - <code class="inlineCodeBlock">foreach</code>, который позволят не только писать меньше кода, но и сократить возможные ошибки, возникающие из-за неправильного указания значений итераторов. Цикл <code class="inlineCodeBlock">foreach</code> еще называют умным <code class="inlineCodeBlock">for</code>, т.к. он позволяет делать кучу вещей, для которых в цикле <code class="inlineCodeBlock">for</code> пришлось бы писать много лишнего кода.<br>Синтаксис работы цикла крайне прост. В качестве первого параметра в теле цикла вы указывается произвольное имя перебираемой единицы, а вторым параметром указывается коллекция, которую необходимо перебрать. <code class="inlineCodeBlock">foreach</code> позволяет одинаково успешно выполнять переборку огромного количества типов, начиная с классических массивов и заканчивая структурами, кортежами, и даже строками в файле. Простейший пример цикла эквивалентный циклу <code class="inlineCodeBlock">for</code>, представленному выше:<br><code class="language-d"><br>void main()<br>{<br>  int [] myarr = [1,2,4,5];<br>  foreach(a;myarr)<br>    writeln(a);<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>1        <br>2        <br>4        <br>5        <br></code><br>Точно так же цикл будет работать при переборке массивов строк. Пример:<br><code class="language-d"><br>void main()<br>{<br>  string [] names = ["Mike", "David", "Jow", "Elvis"];<br>  foreach(name;names)<br>    writeln(name);<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Mike<br>David<br>Jow<br>Elvis<br></code><br>Бывают ситуации, когда необходимо использование порядкового (индексного) номера перебираемого элемента. Для этого просто добавляем элемент счетчика первым значением. Обычно для этого используется буква <code class="inlineCodeBlock">i</code> от слова iterator, но может быть любая другая буква или набор символов.<br>Пример:<br><code class="language-d"><br>void main()<br>{<br>  string [] myarr = ["Mike", "David", "Jow", "Elvis"];<br>  foreach(i, a; myarr)<br>    writefln("i: %s, value: %s", i, a);<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>i: 0, value: Mike<br>i: 1, value: David<br>i: 2, value: Jow<br>i: 3, value: Elvis<br></code><br>Несмотря на универсальность использовать <code class="inlineCodeBlock">foreach</code> лучше для предназначенных для этого типов, которые являют собой понятие *коллекция*. В противном случае, если вы, к примеру, попробуете перебрать элементы класса, то возникнет резонный вопрос о том, в какой последовательности и по каким правилам нужно проводить переборку.<br>&gt;**Tips:** На самом деле <code class="inlineCodeBlock">foreach</code> является лишь оберткой над циклом <code class="inlineCodeBlock">for</code>. Всю остальную работу компилятор делает за вас. При этом стоит отметить, что сам цикл <code class="inlineCodeBlock">for</code> так же является оберткой над циклом <code class="inlineCodeBlock">loop</code>, который и реализуется на уровне машинных команд.<br>Давайте попробуем прочитать текстовый файл и разбить его на строки по произвольному разделителю. В данном случае по запятой. Создадим текстовый файл <code class="inlineCodeBlock">test.txt</code>, в который поместим строку: <code class="inlineCodeBlock">Jow,David,Mike,Piter</code>. Не забудьте, что текстовый файл должен лежать там, где будет находиться исполняемый файл. При сборке проекта <code class="inlineCodeBlock">dub</code> исполняемый файл всегда копируется уровнем выше каталога с исходным кодом <code class="inlineCodeBlock">source</code>, а компилятор <code class="inlineCodeBlock">dmd</code> оставляет скомпилированный файл рядом с файлом исходного кода. Если текстовый файл не будет найден, приложение упадет с ошибкой, т.к. в примерах для сокращения кода мы подобные ситуации не обрабатываем.<br>app.d<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  auto file = File("test.txt", "r"); // открываем файл на чтение, передавая в качестве параметров имя файла и типом доступа (r)ead.<br>  foreach(line; file.byLine(KeepTerminator.no, ',')) //вызываем функцию разбивки по строкам и указываем ей тип разделителя<br>  {<br>    writeln(line);<br>  }<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Jow<br>David<br>Mike<br>Piter<br></code><br>Обратите внимание, что в данном случае мы указали в качестве параметров <code class="inlineCodeBlock">KeepTerminator.no</code>, а значит, сам символ разделителя в выводимых строках будет отсутствовать. Если нам требуется изменить поведение функции и заставить ее выводить символ разделителя, то просто заменим <code class="inlineCodeBlock">KeepTerminator.no</code> на <code class="inlineCodeBlock">KeepTerminator.yes</code>. Результат:<br><code class="language-d"><br>&gt; app.exe  <br>Jow,       <br>David,     <br>Mike,      <br>Piter<br></code><br>[*] В данном примере рассматривается шаблонная функция. Если у вас пока нет опыта работы со структурами, классами и шаблонами, то код следует просто воспринять как должное. Более подробное объяснение этих вещей будет дано в соответствующих главах.<br>Как цикл <code class="inlineCodeBlock">for</code>, так и <code class="inlineCodeBlock">foreach</code> имеют поддержку операторов <code class="inlineCodeBlock">break</code> и <code class="inlineCodeBlock">continue</code>, первый выполняет выход из цикла, второй - пропускает шаг. Примеры их использования приведены в секции с описанием цикла <code class="inlineCodeBlock">while</code>.<br><code class="inlineCodeBlock">foreach</code> поддерживает любой диапазон. Это значит, что мы можем использовать в его теле абсолютно любую функцию, которая возвращает данные с типом <code class="inlineCodeBlock">range</code>. Рассмотрим пример использования библиотеки работы с диапазонами <code class="inlineCodeBlock">std.range</code>. К примеру, нам требуется сделать переборку с данных с шагом 2. Т.е. обработать лишь каждый второй элемент.<br>Рассмотрим метод <code class="inlineCodeBlock">stride</code> сигнатура вызова которого следующая `auto stride(Range)(Range r, size_t n)`.<br><code class="inlineCodeBlock">auto</code> - это то, что он возвращает. Как было указано, использование слова <code class="inlineCodeBlock">auto</code> хоть и позволяет писать более компактный код, но часто заставляет дополнительно вчитываться в описание метода или функции для того, чтобы понять, какой именно тип данных функция возвращает. В данном случае описание говорит нам: `Returns: At minimum, an input range.`.<br>Наверняка вы уже заметили, что большая часть функций в описании имеет два блока скобок: <code class="inlineCodeBlock">foo(...)(...)</code>. Это шаблоны (шаблонные функции). Их поведение мы рассмотрим в соответствующей главе. Поэтому на первый блок скобок мы пока обращать внимание не будем, а сразу переключимся на второй `(Range r, size_t n)`. `Range r` означает, что метод принимает некие данные с типом <code class="inlineCodeBlock">range</code>(диапазон), `size_t n`, идущий вторым параметром означает, что ожидается целое число с типом (размерностью) <code class="inlineCodeBlock">size_t</code>.<br>Мы помним, что <code class="inlineCodeBlock">foreach</code> вторым аргументом принимает диапазон, который как раз и вернет нам функция <code class="inlineCodeBlock">stride</code>. Значит, наш код будет выглядеть следующим образом:<br><code class="language-d"><br>import std.stdio;<br>import std.range; // подключаем модуль работы с диапазонами<br>void main()<br>{<br>  string [] myarr = ["Jow", "David", "Mike", "Piter", "Maria", "Katerina"]; // помним, что строка это тоже range<br>  foreach(element; stride(myarr, 2)) // stride будет возвращать каждый второй элемент<br>  {<br>    writefln("name: %s", element);<br>  }<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>name: Jow<br>name: Mike<br>name: Maria<br></code><br>Обратите внимание, что только элементы в массиве типа <code class="inlineCodeBlock">array</code> поддерживают индексный номер. Это значит, что если вы попробуете записать указанный цикл, добавив туда элемент счетчика <code class="inlineCodeBlock">i</code>, то получите ошибку: `Error: cannot infer argument types, expected 1 argument, not 2`. <br>Для того чтобы добавить к диапазону индексный номер, нужно применить к нему функцию <code class="inlineCodeBlock">enumerate</code> со следующей сигнатурой:<br>`auto enumerate(Enumerator = size_t, Range)(Range range, Enumerator start = 0)`. Второй блок скобок показывает, что функция принимает только один обязательный аргумент - диапазон <code class="inlineCodeBlock">range</code>, знак <code class="inlineCodeBlock">=</code> у второго параметра означает, что если его дополнительно не указать, то будет использовано значение по умолчанию - в данном случае 0.<br>В итоге, чтобы у нашего диапазона появился индексный номер, который бы работал внутри цикла <code class="inlineCodeBlock">foreach</code>, мы должны записать следующий код:<br><code class="language-d"><br>import std.stdio;<br>import std.range; // подключаем модуль работы с диапазонами<br>void main()<br>{<br>  string [] myarr = ["Jow", "David", "Mike", "Piter", "Maria", "Katerina"]; // помним, что строка это тоже range<br>  foreach(i, element; stride(myarr, 2).enumerate) // stride будет возвращать каждый второй элемент<br>  {<br>    writefln("index: %s, name: %s", i, element);<br>  }<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>index: 0, name: Jow<br>index: 1, name: Mike<br>index: 2, name: Maria<br></code><br>В результате оба варианта кода вернули нам каждый второй элемент в диапазоне.<br>Функционал модуля <code class="inlineCodeBlock">std.range</code> крайне обширен и более подробно будет рассмотрен в отдельной главе.<br></div ><br><div id="f91d7295" class="bookcontent"><h3>###Цикл while</h3>Оператор <code class="inlineCodeBlock">while</code> выполняет схожие функции с <code class="inlineCodeBlock">for</code>, однако обычно используется для того, чтобы создать бесконечный цикл, который будет выполняться до тех пор, пока указанное в нем условие будет истинно.<br>Пример:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  int i = 0;<br>  while(i&lt;5) // условие выполняется пока <code class="inlineCodeBlock">i</code> меньше 5<br>  {<br>    i++; // инкрементируем i на единицу на каждом шаге цикла<br>    writeln("i: ", i);<br>  }<br>  writeln("Outside while loop"); // цикл while уже завершился<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>i: 0<br>i: 1<br>i: 2<br>i: 3<br>i: 4<br>Outside while loop<br></code><br>&gt;**Tips:** Так же язык поддерживает оператор <code class="inlineCodeBlock">do</code>, который работает по схожему принципу с оператором <code class="inlineCodeBlock">while</code>. Однако в силу того, что он крайне редко используется в реальной жизни, мы не будем его рассматривать.<br><div id="6abd9b37" class="bookcontent"><h4>####Оператор цикла continue</h4>Бывают случаи, когда при работе с циклом требуется проверить какое-то условие, и если оно истинно, то не выполнять следующий за ним блок кода, а сразу перейти к следующему шагу.<br>Пример: <br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  int i = 0;<br>  while(i&lt;5)<br>  {<br>    i++; // инкрементируем i на единицу на каждом шаге цикла<br>    if(i==4) // если i равно 4<br>      continue; // пропустить шаг и не выполнять следующий код<br>    writeln("i: ", i);<br>  }<br>  writeln("Outside while loop"); // цикл while уже завершился<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>i: 1<br>i: 2<br>i: 3<br>i: 5<br>Outside while loop<br></code><br>Как вы видите, в выводе отсутствует число 4, т.к. сразу после проверки цикл не стал выполняться дальше, а сразу перешел к следующему шагу и вывел число 5.<br></div ><br><div id="876c7feb" class="bookcontent"><h4>####Оператор цикла break</h4>Бывают случаи, когда при достижении какого-то условия нам не нужно выполнять блок кода дальше и требуется выйти из цикла. Для этого используется оператор <code class="inlineCodeBlock">break</code>. В предыдущем примере давайте заменим оператор <code class="inlineCodeBlock">continue</code> на <code class="inlineCodeBlock">break</code> и посмотрим на результат.<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  int i = 0;<br>  while(i&lt;5)<br>  {<br>    i++; // инкрементируем i на единицу на каждом шаге цикла<br>    if(i==4) // если i равно 4<br>      break; // выходим из цикла<br>    writeln("i: ", i);<br>  }<br>  writeln("Outside while loop"); // цикл while уже завершился<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>i: 1<br>i: 2<br>i: 3<br>Outside while loop<br></code><br></div ><br></div ><br><div id="663f3cf8" class="bookcontent"><h3>###Оператор switch-case</h3><br>Если оператор <code class="inlineCodeBlock">if</code> используется для проверки какого-либо условия, то связка операторов <code class="inlineCodeBlock">switch-case</code> обычно применяется там, где нужно проверить какую-либо переменную на совпадение с множеством возможных значением. Чисто технически ничего вам не мешает выполнять подобную проверку с использованием <code class="inlineCodeBlock">if</code>, `else if`, <code class="inlineCodeBlock">else</code>. В некоторых случаях код может получиться даже короче.<br><code class="inlineCodeBlock">switch-case</code> по своей сути лишь рудимент от C/C++, который остался в D исключительно для упрощения процесса портирования кода. Польза в реальных проектах крайне низка. Современная CS (Computer Science) рассматривает паттерн-матчинг (сопоставление с образцом) как более передовой вариант блока <code class="inlineCodeBlock">switch-case</code>. Концепция паттерн-матчинга пришла из функциональных языков программирования и позволяет не только писать меньше кода, но и выполнять сопоставление с различными типами данных, такими как: срезы, диапазоны, включать различные выражения в сопоставление и т.д. В настоящий момент паттерн-матчинг реализован лишь в нескольких языках, в число которых D к сожалению пока не входит, однако в дальнейшем такой функционал обязательно появится.<br>Правила использования лучше всего покажет следующий пример:<br><code class="language-d"><br>import std.stdio;<br>import std.range; // подключаем модуль работы с диапазонами<br>void main()<br>{<br>  string name = "Maria";<br>  switch(name)<br>  {<br>    case "Jow": // если имя совпало, вызываем функцию, расположенную ниже<br>      sayHello(name); // вызываемая в случае совпадения функция<br>      break; // обязательно прерываем выполнение, т.к. искомое значение найдено<br>    case "David":   <br>      sayHello(name); // ... <br>      break;<br>    case "Maria":<br>      sayHello(name); // ... <br>      break;<br>    case "Piter":<br>      sayHello(name); // ... <br>      break;<br>    default: // обязательная секция, которая срабатывает, если ни одно из сравнений не совпало<br>      writeln("Unknow name"); <br>      break;<br>  }<br>}<br>void sayHello(string userName) // Принимает имя пользователя userName с типом string<br>{<br>  writeln("Hello, ", userName);<br>}<br></code><br>Тот же самый код, записанный при помощи <code class="inlineCodeBlock">if</code>, `else if`, <code class="inlineCodeBlock">else</code>:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  string name = "Maria";<br>  if (name == "Jow")<br>    sayHello(name); // вызываемая в случае совпадения функция<br>  else if (name == "David")<br>    sayHello(name); // ... <br>  else if (name == "Maria")<br>    sayHello(name); // ... <br>  else if (name == "Piter")<br>    sayHello(name); // ... <br>  else<br>    writeln("Unknow name");<br>}<br>void sayHello(string userName) // Принимает имя пользователя userName с типом string<br>{<br>  writeln("Hello, ", userName);<br>}<br></code><br>Оба варианта будут давать одинаковый результат:<br><code class="language-d"><br>&gt; app.exe<br>Hello, Maria<br></code><br><div id="dfd51513" class="bookcontent"><h4>####Арифмитические операторы</h4><code class="inlineCodeBlock">+</code> сложение. Пример: <code class="inlineCodeBlock">2+3</code>.<br><code class="inlineCodeBlock">-</code> вычитание. Пример: <code class="inlineCodeBlock">3-2</code>.<br><code class="inlineCodeBlock">++</code> инкремент (увеличение на единицу). Пример: `int i=2`. <code class="inlineCodeBlock">i++</code>. Результат: <code class="inlineCodeBlock">i</code> равно 3.<br><code class="inlineCodeBlock">--</code> декремент (уменьшение на единицу). Пример: `int i=3`. <code class="inlineCodeBlock">i--</code>. Результат: <code class="inlineCodeBlock">i</code> равно 2.<br><code class="inlineCodeBlock">*</code> умножение. Пример: <code class="inlineCodeBlock">2*3</code>. Результат: 6.<br><code class="inlineCodeBlock">/</code> деление. Пример: <code class="inlineCodeBlock">6/3</code>. Результат: 2.<br><code class="inlineCodeBlock">^^</code> возведение в степень. Пример: <code class="inlineCodeBlock">2^^3</code>. Результат: 8.<br>Если требуется получить результат в тот же самый оператор, из которого мы берем данные, то возможно использовать краткую запись. Предположим, что <code class="inlineCodeBlock">i</code> у нас равно 5. Для того, чтобы прибавить к <code class="inlineCodeBlock">i</code> число 2 и вернуть результат в <code class="inlineCodeBlock">i</code> , можно записать как `i = i + 2;`, так и `i += 2;`. Обе записи будут абсолютно корректны. <br>Обратите внимание на размерность типов. Если вы попытаетесь записать в тип больше, чем он может в себя вместить, вы получите ошибку целочисленного переполнения. Как это выглядит? К примеру, тип <code class="inlineCodeBlock">byte</code> позволяет хранить в себе как положительные, так и отрицательные числа от -128 до +127. Если вы к 127 прибавите единицу, то вместо ожидаемых 128 вы получите -128. То же самое с другими типами. В момент компиляции компилятор проверяет размерность данных, так что он просто не даст вам записать в переменную некорректное значение, однако он не проверяет значения, которые были высчитаны в процессе работы.<br>Рассмотрим пример:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  byte x = 127;<br>  while(x&lt;=128) // условие не выполнится никогда, и цикл будет вечный<br>  {<br>    x++; // если бы x мог стать &gt;129, то он бы не выполнялся<br>    writeln(x); <br>    readln; // для наглядности все делаем в пошаговом режиме<br>  }<br>  <br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>-128<br>-127<br>-126<br>...<br>-2  <br>    <br>-1  <br>    <br>0   <br>    <br>1  <br></code><br>Размеры целочисленных типов:<br>|тип |размер |по умолчанию|<br>|-- |------ | ---------- |<br>|byte  |-128 .. 127   |0|<br>|ubyte |255    |0|<br>|short  |-32768 .. 32767  |0|<br>|ushort  |65,535  |0|<br>|int     |–2,147,483,648 .. 2,147,483,647 |0|<br>|uint  |4294967295  |0|<br>|long  |-9223372036854775808 .. 9223372036854775807 |0L|<br>|ulong   |18446744073709551615  |0L|<br>Количество поддерживаемых типов в D весьма велико, и полную их таблицу можно посмотреть в документации. Мы остановимся лишь на двух популярных.<br>Размеры дробных типов:<br>|тип |размер |точность после запятой|<br>|-- |------ | ---------- |<br>|float  |1.17549e-38 to 3.40282e+38   |6|<br>|double |2.22507e-308 to 1.79769e+308   |15|<br><br></div ><br></div ><br></div ><br><div id="e1fbc56e" class="bookcontent"><h2>##Взаимодействие с операционной системой посредством Input/Output</h2><div id="de88f0b8" class="bookcontent"><h4>####Аргументы main</h4>Существует большое количество способов передавать параметры в наше приложение, самый простой - при помощи аргументов командной строки, с которыми вызывается наше приложение. Самым простым примером будет передача аргументов непосредственно в тело нашей точки входа <code class="inlineCodeBlock">main()</code>.<br>Рассмотрим пример: <br><code class="language-d"><br>import std.stdio;<br>// приложение принимает массив строк, которые в теле будут под именем args<br>void main(string [] args) // вместо args может быть использовано любое другое слово<br>{<br>  writeln("You passed to app next arguments: ");<br>  foreach(arg; args[1..$])<br>  {<br>    writeln("Argument: ", arg);<br>  }<br>}<br></code><br>Теперь при запуске нашего приложения мы можем передать ему набор любых параметров через пробел, и все они будут выведены при его старте:<br><code class="language-d"><br>&gt; app.exe -foo +bar baz<br>You passed to app next arguments:<br>Argument: -foo<br>Argument: +bar<br>Argument: baz<br></code><br>Обратите внимание, что при переборке значений в теле <code class="inlineCodeBlock">foreach</code> мы используем конструкцию <code class="inlineCodeBlock">args[1..$]</code>. Это слайс. Знак доллара означает последний элемент. В данном случае мы производим переборку ,начиная с первого элемента и заканчивая последним. Нулевой элемент мы в переборку не включаем. Это происходит по той причине, что по традиции нулевым аргументом является имя самого приложения, и если мы включим в выборку, то результат примет вид:<br><code class="language-d"><br>&gt; app.exe -foo +bar baz<br>You passed to app next arguments:<br>Argument: app.exe<br>Argument: -foo<br>Argument: +bar<br>Argument: baz<br></code><br>Обычно таким образом передаются параметры, которые влияют на ход выполнения приложения. Чисто технически мы можем проверять эти параметры и на основании них менять ход выполнения приложения. Однако если ваше приложение будет принимать больше 1-2 аргументов, так лучше не делать, т.к. есть более специализированные варианты.<br></div ><br><div id="78285ae4" class="bookcontent"><h4>####Парсинг аргументов командной строки при помощи getopt</h4><code class="inlineCodeBlock">getopt</code> позволяет принимать аргументы командной строки, и делает это согласно определенным правилам. Обычно аргументы передаются в формате <code class="inlineCodeBlock">--key=value</code>, возможно так же использовать краткую запись <code class="inlineCodeBlock">-l=value</code>. Символом разделителя ключа и его значения так же может быть пробел: `--key value`, `-l value`.<br>Для работы <code class="inlineCodeBlock">getopt</code> необходимо подключить модуль <code class="inlineCodeBlock">std.getopt</code>. Сигнатура функции <code class="inlineCodeBlock">getopt</code> следующая: `GetoptResult getopt(T...)(ref string[] args, T opts);`. Возвращает она тип <code class="inlineCodeBlock">GetoptResult</code>, в качестве первого параметра принимает ссылку на входящие аргументы, принятые в <code class="inlineCodeBlock">main</code>, в качестве второго значения аргументов. <code class="inlineCodeBlock">T</code> означает некий абстрактный тип. Мы ведь можем принимать не только тип <code class="inlineCodeBlock">string</code>, но и <code class="inlineCodeBlock">int</code>, <code class="inlineCodeBlock">bool</code>, <code class="inlineCodeBlock">enum</code> и другие.<br>По умолчанию аргументы командной строки не чувствительны к регистру и ключи <code class="inlineCodeBlock">--foo</code> и <code class="inlineCodeBlock">--Foo</code> будут работать одинаково.<br>Для того, чтобы использовать однобуквенные аргументы, как, к примеру, <code class="inlineCodeBlock">-p</code> вместо <code class="inlineCodeBlock">--password</code>, необходимо указать эти сокращенные версии через символ <code class="inlineCodeBlock">|</code>. Пример: <br><br>Пример:<br><code class="language-d"><br>import std.stdio;<br>import std.getopt;<br>void main(string [] args)<br>{<br>  string login; <br>  string pass; <br>  getopt(args, <br>  "login|l", &login,<br>  "password|p", &pass);<br>  if (login == "admin" && pass == "superpass")<br>    writeln("You are logged as administrator");<br>  else if (login.length == 0 && pass.length == 0) // если логин И пароль не указаны<br>    writeln("No argumens specified");<br>  else<br>    writeln("Credentials is invalid");    <br>}<br></code><br>Теперь мы можем запускать наше приложение, передавая любые комбинации следующих аргументов:<br><code class="language-d"><br>&gt; app.exe -l admin -p superpass<br>You are logged as administrator<br>&gt; app.exe --l admin -p superpass<br>You are logged as administrator<br>&gt; app.exe --login admin -p superpass<br>You are logged as administrator<br>&gt; app.exe --login admin --password superpass<br>You are logged as administrator<br>&gt; app.exe --login admin --password=superpass<br>You are logged as administrator<br>&gt; app.exe --l=admin --password=superpass<br>You are logged as administrator<br></code><br>Несколько советов:<br>1. Если вам нужно установить булевое значение в <code class="inlineCodeBlock">true</code>, то не обязательно писать <code class="inlineCodeBlock">--writelog=true</code>, достаточно просто написать <code class="inlineCodeBlock">--writelog</code>.<br>2. Если ключ (`string[] outputFiles;`) принимает массив значений (к примеру, набор имен файлов), тогда следует установить строковую переменную <code class="inlineCodeBlock">arraySep</code>, указав ей значение разделителя и дальше передать через него набор входных значений. Пример:<br><code class="language-d"><br>string[] outputFiles;<br>arraySep = ",";  // По умолчанию разделитель пробел, но он может создать лишнюю путаницу<br>getopt(args, "output", &outputFiles);<br></code><br>Теперь параметры можно задавать так <code class="inlineCodeBlock">--output=myfile.txt,yourfile.txt</code> или так `--output myfile.txt,yourfile.txt`.<br>По умолчанию не включена обработка ошибок, так как если вы передадите программе неизвестный ключ, то она у вас упадет с исключением. Это сделано специально, т.к. дает программисту выбирать как должно вести себя приложение, если оно получило некорректные аргументы на входе. Однако существует возможность <code class="inlineCodeBlock">getopt</code>, что он должен игнорировать все неизвестные ему аргументы. Для этого следует установить параметр <code class="inlineCodeBlock">std.getopt.config.passThrough</code>.<br>Пример:<br><code class="language-d"><br>...<br>  getopt(args, std.getopt.config.passThrough,<br>  "login|l", &login,<br>  "password|p", &pass);<br>...<br></code><br>Теперь при передаче неизвестных параметров исключение вылетать не будет.<br>В некоторых случаях бывает полезно сделать некоторые ключи обязательными и информировать пользователя, что без их указания невозможно продолжить работу. Для этого используется параметр <code class="inlineCodeBlock">std.getopt.config.required</code>.<br>Пример:<br><code class="language-d"><br>...<br>  getopt(args, <br>  "login|l", &login,<br>  std.getopt.config.required, "password|p", &pass); // пароль обязателен<br>...<br></code><br>Теперь, если мы запустим наше приложение, указав только логин и забудем указать пароль, то получим исключение (которое, разумеется, следует обработать):<br><code class="language-d"><br>&gt; app.exe -l Jow<br>std.getopt.GetOptException@\src\phobos\std\getopt.d(727): Required option password|p was not supplied<br></code><br><div id="02aa8c9b" class="bookcontent"><h5>#####Генерация help</h5>Как вы заметили <code class="inlineCodeBlock">getopt</code> возвращает структуру с типом <code class="inlineCodeBlock">GetoptResult</code>, содержащую в себе информацию обо всех возможных ключах, которые приложение рассчитывает получить в качестве возможных аргументов. Это бывает полезно для генерации справочной информации. <br>Для активации генерации справки явно писать обработку аргументов <code class="inlineCodeBlock">--help|h</code> не требуется. <code class="inlineCodeBlock">getopt</code> уже ожидает эти аргументы. Для того чтобы вывести справку, достаточно лишь проверить булевый флаг <code class="inlineCodeBlock">helpWanted</code> у переменной, содержащей в себе результаты <code class="inlineCodeBlock">getopt</code>.<br><code class="language-d"><br>  if(result.helpWanted) // проверяем, не был ли передан ключ <code class="inlineCodeBlock">--help|h</code><br>    writeln("Help");<br></code><br>Пример:<br><code class="language-d"><br>import std.stdio;<br>import std.getopt;<br>void main(string [] args)<br>{<br>  string login; <br>  string pass; <br>  auto result = getopt(args,<br>  std.getopt.config.passThrough, // не падаем с исключением, если переданы неизвестные аргументы<br>  "login|l", &login,<br>  "password|p", &pass); // получаем аргументы, но не обрабатываем их<br>  if(result.helpWanted) // проверяем, не был ли указан ключ --help|h<br>  {<br>     defaultGetoptPrinter("Help: ", result.options); // Печатаем доступные аргументы.<br>  }<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe -h<br>Help:<br>-l    --login<br>-p --password<br>-h     --help This help information.<br></code><br>Если мы хотим снабдить каждый ключ дополнительным комментарием, то после имени параметра просто укажем произвольный текст:<br><code class="language-d"><br>...<br>  auto result = getopt(args,<br>  std.getopt.config.passThrough, // не падаем с исключением, если переданы неизвестные аргументы<br>  "login|l", "Login option discription", &login, // произвольное описании параметра login<br>  "password|p", "Password should be at last 5 digits" ,&pass); // произвольное описании параметра password<br>...<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe -h<br>Help:<br>-l    --login Login option discription<br>-p --password Password should be at last 5 digits<br>-h     --help This help information.<br></code><br>Для более удобного восприятия мы можем воспользоваться символом апострофа, описанным в разделе, посвященном форматированию строк, и обрамить наши комментарии к параметрам им так, чтобы в результате они выводились в кавычках.<br>Пример:<br><code class="language-d"><br>  auto result = getopt(args,<br>  std.getopt.config.passThrough, // не падаем с исключением, если переданы неизвестные аргументы<br>  "login|l", `"Login option discription"`, &login,<br>  "password|p", `"Password should be at last 5 digits"` ,&pass); // получаем аргументы, но не обрабатываем их<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe -h<br>Help:<br>-l    --login "Login option discription"<br>-p --password "Password should be at last 5 digits"<br>-h     --help This help information.<br></code><br></div ><br></div ><br></div ><br><div id="ddc9a64f" class="bookcontent"><h2>##Обработка ошибок</h2><div id="5cf75075" class="bookcontent"><h3>###Исключения</h3>Во время исполнения приложения могут возникать ошибки двух типов. К первому типу относятся исключения (Exceptions). Ко второму - ошибки (Errors). Исключениями называются ошибки такого рода, который программист может перехватить и каким-либо образом обработать. Исключения перехватывать можно и нужно. Ошибки фатальны, и перехватить их **нельзя**. К примеру, если программа попытается прочитать отсутствующий файл, то не всегда будет правильно допускать падение приложение, особенно если этот файл не является необходимым для дальнейшей работы. <br>Исключения удобнее представлять как объект, которые содержит информацию о возникшей ошибке. В языке реализован специальный базовый класс исключений <code class="inlineCodeBlock">std.exception</code>, от которого наследуются все остальные исключения. Правильно реализованная система исключений крайне важна, так как в больших проектах без нее становится практически невозможно найти ошибку. Именно поэтому большинство классов, выполняющие действия, которые могут привести к потенциальным ошибкам, имеют свой собственный набор исключений (унаследованный от базового класса). К примеру, класс, работающий с файловой системой, обычно имеет реализацию системы исключений, которая касается исключительно файловой системы. Класс, который работает с базой данных, реализует исключений для базы данных и т.д.<br>Нет никаких проблем выбрасывать исключения напрямую, унаследованные от <code class="inlineCodeBlock">std.exception</code>, и многие библиотеки так делают, однако в некоторых случаях имеет смысл реализовывать и выбрасывать исключения уникального типа.<br>Рассмотрим пример самого простого исключения (пока рассматриваем исключительно реализацию базового класса исключений <code class="inlineCodeBlock">std.exception</code>). Предположим, мы пишем приложение, обрабатывающее <code class="inlineCodeBlock">.xml</code> файлы. И тут происходит неожиданная ситуация: пользователь пытается открыть в приложении файл <code class="inlineCodeBlock">.png</code>. Библиотека (или модуль приложения, где происходит обработка) должна как-то проинформировать использующее ее приложение о том, что тип файла не соответствует ожидаемому, чтобы приложение само решило, как быть в данной ситуации.<br>Кроме того, что функция должна выбросить исключение, вызывающий код его должен как-то поймать. Для поимки исключения используется блок <code class="inlineCodeBlock">try-catch</code>. Блок <code class="inlineCodeBlock">try</code> отвечает за нормальное выполнение, а блок <code class="inlineCodeBlock">catch</code> за обработку исключения, если оно все же случилось в блоке <code class="inlineCodeBlock">try</code>.<br>Пример:<br><code class="language-d"><br>import std.stdio;<br>import std.algorithm; // endsWith позволяет проверить конец строки<br>void main()<br>{<br>  string filename = "myimage.png";<br>  try<br>  {<br>    write("My First Exception: ");<br>    processXMLFile(filename); // передаем имя файла в функцию, ожидающую xml файл  <br>  }<br>  catch(Exception e) // создаем объект исключения<br>  {<br>    writeln(e.msg); // обращаемся к полю, содержащему текст исключения<br>  }<br>  finally<br>  {<br>    // не зависимо от того, поймали ли мы исключение или нет, выполняем какую-либо операцию<br>  }<br>  <br>}<br>void processXMLFile(string name) // реализованная где-то в библиотеке функция. Принимает имя файла<br>{<br>  if(!name.endsWith(".xml")) // если имя не заканчивается на ".xml"<br>    throw new Exception("Wrong file type"); // выкидываем исключение<br>  // Продолжаем нормальный ход выполнения<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>My First Exception: Wrong file type<br></code><br>Хорошей практикой при обработке исключений является использование блока <code class="inlineCodeBlock">finally</code>, код в котором выполняется не зависимо от того, отработал ли блок <code class="inlineCodeBlock">try</code> без ошибок, или вызываемый код выбросил исключение и управление было передано в обработчик <code class="inlineCodeBlock">catch</code>. В блок <code class="inlineCodeBlock">finally</code> принято помещать код, который необходимо выполнить и в том и в другом случае. К примеру, не зависимо от того, были ли отправлены данные в базу данных, нам надо закрыть к ней подключение.<br>Как было сказано выше, исключения делятся на отдельные типы в зависимости от того, что их породило. Была ли это ошибка файловой системы, ошибка обработки самого файла или ошибка в чем-то другом. Поэтому в сложных проектах принято писать отдельный обработчик <code class="inlineCodeBlock">catch</code> для каждого типа ошибок. Обычно каждая библиотека снабжена документацией, в которой содержится перечень исключений с их типами, которые она может выбрасывать.<br>Выкидывание разных типов исключений вместо базового типа <code class="inlineCodeBlock">Exception</code> полезно тем, что у программиста появляется возможность не только более точно понимать, какого рода произошла ошибка в вызываемой функции, но и для каждого отдельного типа создавать свой обработчик. Это позволяет крайне гибко обрабатывать всевозможные ошибки. Технически нет проблем везде кидать базовый тип <code class="inlineCodeBlock">Exception</code> вместо специализированного, однако это считается плохим тоном. <br>Обратите внимание. Исключения нужно кидать лишь когда возникает какая-то действительно нештатная ситуация и нужно проинформировать об этом код, который находится уровнем выше. К примеру, на уровне библиотеки, обрабатывающей <code class="inlineCodeBlock">.ini</code> файлы, ошибка доступна к файлу или ошибка его структуры является нештатной ситуацией. Так что исключения нужно кидать только тогда, когда есть все логические основания считать, что код уровнем выше должен их ловить.<br>Как уже было сказано выше, значительна часть библиотек реализовывает свои классы исключений, унаследованные от базового <code class="inlineCodeBlock">Exception</code>. К примеру, библиотека <code class="inlineCodeBlock">std.stdio</code> выкидывает исключения с типом <code class="inlineCodeBlock">StdioException</code>, <code class="inlineCodeBlock">std.conv</code> с типом <code class="inlineCodeBlock">ConvOverflowException</code>, <code class="inlineCodeBlock">std.utf</code> с типом <code class="inlineCodeBlock">UTFException</code> и т.д. Обычно документация содержит не только перечень функций библиотеки, но и типы исключений, которые она может выбрасывать.<br>В результате в коде для каждого типа исключений мы можем использовать свой собственный  <code class="inlineCodeBlock">catch</code> блок.<br><code class="language-d"><br>    try {<br>        // выполняем блок кода, который может выбрасывать исключения<br>    } catch (first_exception_type) <br>    {<br>        // ловим первый тип исключений<br>        // делаем какую-то обработку<br>    } <br>    catch (second_exception_type) <br>    {<br>        // ловим второй тип исключений, который так же может выбрасываться<br>        // делаем какую-то обработку<br>    }<br>    catch (Exception)  // ловим базовый тип исключений<br>    {<br>        // ловим второй тип исключений, который так же может выбрасываться<br>        // делаем какую-то обработку<br>    } <br>    finally {<br>        // Выполняем действия не зависимо от того, были ли брошены исключения или нет<br>    }<br></code><br>Каждый блок <code class="inlineCodeBlock">catch</code> ловит исключительно тот тип исключений, который указан у него в параметрах. Так, если библиотека наряду с частными исключениями может выбрасывать какое-то общее с типом <code class="inlineCodeBlock">Exception</code>, то непременно в самом конце нужно поймать и его.<br><br>В некоторых случаях обработки внутри блока <code class="inlineCodeBlock">catch</code> бывает недостаточно и для того, чтобы проинформировать код, который находится уровнем выше, мы внутри блока <code class="inlineCodeBlock">catch</code> можем выбрасывать исключение повторно.<br>Выглядит это следующим образом:<br><code class="language-d"><br>  try <br>  {<br>  // ...  <br>  }<br>  catch(Exception e) // ловим исключение, случившееся в блоке try<br>  {<br>    throw new Exception("Exception text"); // прокидываем его выше<br>  }<br></code><br>Так как все исключения наследуются от базового класса <code class="inlineCodeBlock">Exception</code> (точнее от его интерфейса), то во всех из них есть базовый набор свойств:<br>- <code class="inlineCodeBlock">.file</code>: Имя файла, в котором произошло исключение<br>- <code class="inlineCodeBlock">.line</code>: Номер строки, откуда оно брошено<br>- <code class="inlineCodeBlock">.msg</code>: Текст исключения<br>- <code class="inlineCodeBlock">.info</code>: Состояние стека, когда исключение было брошено<br>- <code class="inlineCodeBlock">.next</code>: Следующее исключение, расположенное за текущим<br><br><div id="11fb98e4" class="bookcontent"><h4>#### Атрибут nothrow</h4><br>Бывают ситуации, когда некоторые функции не должны бросать исключения. Обычно это происходит в разных высококритичных к надежности программных компонентах, в которых любое непредвиденное поведение (а исключения являются именно таким случаем) просто недопустимо, т.к. невозможно на 100% быть уверенным, что никакие данные не были повреждены. То есть если ошибка все же возникла, то продолжать работу просто бесполезно. С этой целью используется атрибут <code class="inlineCodeBlock">nothrow</code>. Которым помечается функция, после чего при любой попытке породить в ней исключение компилятор будет ругаться. <br>Пример:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  foo();  <br>}<br>void foo() nothrow<br>{ <br>  throw new Exception("Exception text"); <br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; dmd app.d<br>app.d(10): Error: object.Exception is thrown but not caught<br>app.d(8): Error: nothrow function 'app.foo' may throw<br></code><br><br></div ><br><div id="9f1c7ce0" class="bookcontent"><h4>#### Блок scope</h4><br>В D реализована так же поддержка так называемых <code class="inlineCodeBlock">scope</code>. Они позволяют очень компактно записывать, что нужно сделать при выходе из блока кода. Синтаксис их крайне прост.<br><code class="inlineCodeBlock">scope(exit)</code> выполняется, если код вышел за пределы блока. Не зависимо, что было причиной: исключение или нормальное завершение<br><code class="inlineCodeBlock">scope(success)</code> выполняется исключительно, если блок был выполнен успешно<br><code class="inlineCodeBlock">scope(failure)</code> выполняется, если в блоке произошло исключение<br>Если за <code class="inlineCodeBlock">scope()</code> выражением идет лишь одна строка, то фигурные скобки ставить не обязательно. Пример: `scope(exit) writeln("Will be written when exit");`<br>Если требуется выводить при помощи <code class="inlineCodeBlock">scope()</code> большой блок кода, то она записывается в фигурных скобках.<br><code class="language-d"><br>scope(success) {<br>        writeln("Some text 1");<br>        writeln("Some text 2");<br>    }<br></code><br>Пример:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  writeln("Hello before");<br>  foo();<br>  writeln("Hello after");<br>  <br>}<br>void foo()<br>{<br>    scope(exit) writeln("1");<br>    scope(success) writeln("2");<br>    scope(exit) writeln("3");<br>    scope(failure) writeln("4"); // никогда не будет выведено<br>}<br></code><br>Результат: <br><code class="language-d"><br>&gt; app.exe<br>Hello before<br>3<br>2<br>1<br>Hello after<br></code><br>А вот теперь давайте попробуем бросить в функции <code class="inlineCodeBlock">foo()</code> исключение и посмотреть что будет:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  writeln("Hello before");<br>  foo();<br>  writeln("Hello after");<br>  <br>}<br><br>void foo()<br>{<br>    scope(exit) writeln("1");<br>    scope(success) writeln("2"); // никогда не будет выведено, т.к. успех не равно ошибке<br>    scope(exit) writeln("3");<br>    scope(failure) writeln("4");<br>      throw new Exception("My Exception"); // кидаем исключение, чтобы сработал блок failure<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Hello before<br>4<br>3<br>1<br>object.Exception@app.d(23): My Exception<br></code><br></div ><br></div ><br><div id="42576230" class="bookcontent"><h3>###Логирование</h3><br>Большинство приложений как минимум в процессе своей отладки записывают возникающие ошибки в текстовый файл. Для этих целей Phobos реализован специальный модуль <code class="inlineCodeBlock">std.experimental.logger</code>. <code class="inlineCodeBlock">std.experimental.logger</code> позволяет не только записать ошибки в файл, но и посредством специальных флагов (<code class="inlineCodeBlock">LogLevel</code>) дать возможность программисту указать какого рода ошибки он хочет перехватить. Это могут быть как безобидные информационные предупреждения, так и критические ошибки.<br>Для того, чтобы включить логирование, в приложении не обязательно создавать экземпляр класса <code class="inlineCodeBlock">FileLogger</code>. В некоторых случаях можно использовать отдельные функции, которые имеют те же самые имена, что и методы класса <code class="inlineCodeBlock">FileLogger</code>. Список функций:<br>  <code class="inlineCodeBlock">log</code><br>  <code class="inlineCodeBlock">trace</code><br>  <code class="inlineCodeBlock">info</code><br>  <code class="inlineCodeBlock">warning</code><br>  <code class="inlineCodeBlock">critical</code><br>  <code class="inlineCodeBlock">fatal</code><br>Имя файла, в который вызываемые функции будут записывать лог, можно установить, задав значение свойства <code class="inlineCodeBlock">sharedLog</code> следующим образом:<br><code class="language-d"><br>sharedLog = new FileLogger("New_Default_Log_File.log");<br></code><br>Это свойство  определяет, куда именно выводить лог. Если его оставить (или снова сбросить) в значении по умолчанию (<code class="inlineCodeBlock">null</code>), то лог будет выводиться на консоль, а если установить, то в файл. <br>Несколько слов о том, что происходит в этом коде (подробнее мы поговорим про это в главе, посвященной ООП).<br><code class="inlineCodeBlock">sharedLog</code> является свойством (<code class="inlineCodeBlock">@property</code>), которое можно установить точно так же как переменную. `new FileLogger("New_Default_Log_File.log");`создает экземпляр класса, в конструкторе которого устанавливается значение имени файла с логами, и это самое значение назначается на <code class="inlineCodeBlock">sharedLog</code>.<br>Данное свойство должно быть задано уровнем выше вызываемых функций так, чтобы они имели доступ к его значению. <br>Если же вы создаете экземпляр класса, то в его параметрах при создании вы указываете желаемое имя лог-файла. Пример:<br><code class="language-d"><br>auto fLogger = new FileLogger("NameOfTheLogFile.log");<br></code><br>Рассмотрим более подробно, как это выглядит на практике. В первом случае мы установим значение <code class="inlineCodeBlock">sharedLog</code> и будем писать наши логи в файл.<br><code class="language-d"><br>import std.stdio;<br>import std.experimental.logger;<br>void main()<br>{<br>  sharedLog = new FileLogger("New_Default_Log_File.log");<br>  log("Log message: ");<br>  info("Info message: ");<br>  warning("Warining: ");<br>  error("Error: ");<br>  critical("Critical error: ");<br>  //fatal("Fatal error: ");<br>}<br></code><br>На консоль у нас не будет выведено ничего, зато в файле `` появятся следующие записи:<br><code class="language-d"><br>2017-01-30T15:38:20.073:app.d:main:8 Log message: <br>2017-01-30T15:38:20.073:app.d:main:9 Info message: <br>2017-01-30T15:38:20.073:app.d:main:10 Warining: <br>2017-01-30T15:38:20.073:app.d:main:11 Error: <br>2017-01-30T15:38:20.073:app.d:main:12 Critical error: <br></code><br>Обратите внимание, что у всех без исключения указанных функций есть версии с поддержкой форматирования. Точно так же, как у <code class="inlineCodeBlock">writeln</code> есть аналог <code class="inlineCodeBlock">writefln</code>. То есть если вам требуется в сообщение лога вставить какое-то значение, из кода просто напишите: `logf("Log message: %s", x);`, где <code class="inlineCodeBlock">x</code> будет строка со значением, определенная где-то выше.<br>Если того требуется, вы можете создать полноценный экземпляр класса <code class="inlineCodeBlock">FileLogger</code> и пользоваться его методами. Выглядеть это будет следующим образом:<br><code class="language-d"><br>import std.stdio;<br>import std.experimental.logger;<br>void main()<br>{<br>  auto fLogger = new FileLogger("TestLogFile.log");<br>  fLogger.log("Log message: ");<br>  fLogger.info("Info message: ");<br>  fLogger.warning("Warining: ");<br>  fLogger.error("Error: ");<br>  fLogger.critical("Critical error: ");<br>  //fLogger.fatal("Fatal error: ");<br>}<br></code><br>В итоге будет создан лог-файл <code class="inlineCodeBlock">TestLogFile.log</code>, абсолютно идентичный предыдущему.<br>Разница между двумя способами - вызовом отдельных функций и созданием экземпляра класса заключается в двух моментах:<br>1. Экземпляр класса создает новый неймспейс, и у вас появляется возможность использовать другую функцию с именем, к примеру, <code class="inlineCodeBlock">log</code> (при условии, что вы не импортировали функцию <code class="inlineCodeBlock">log</code> при подключении <code class="inlineCodeBlock">std.experimental.logger</code>)<br>2. При использовании экземпляра класса у вас есть возможность унаследоваться от <code class="inlineCodeBlock">Logger</code> и переопределить его поведение.<br><div id="3f95cd68" class="bookcontent"><h4>####Tuples</h4><br>Иногда бывает нужно упаковать несколько разнотипных значений в один объект. Для этой цели используются кортежи (Tuples). Кортеж представляет из себя нечто среднее между структурой и массивом. С одной стороны элементы в нем могут иметь различный тип как в структуре, с другой - у них есть индексный номер как в массиве. Некоторые типы являются кортежами, к примеру <code class="inlineCodeBlock">DicEntry</code>, содержащий записи о директории является ни чем иным, как кортежем.<br><code class="language-d"><br>alias DicEntry = Tuple!(string, string); // имена можно опустить<br></code><br>Для работы с кортежами необходимо подключить библиотеку <code class="inlineCodeBlock">std.typecons</code>. После чего создать кортеж можно будет двумя способами.<br>1. Вызывать функцию <code class="inlineCodeBlock">tuple</code> и передать в нее данные как аргументы<br>2. Вызывать конструктор типа <code class="inlineCodeBlock">Tuple</code> и передать в него набор шаблонных аргументов и сами данные:<br><code class="language-d"><br>import std.stdio;<br>import std.typecons;<br>void main()<br>{<br>  auto myTuple = tuple(42, "Hello"); // вызываем функцию, создающую кортеж<br>  writeln(myTuple); // выводим структуру кортежа<br>  writeln(myTuple[0]); // выводим первый элемент кортежа<br>  writeln(myTuple[1]); // выводим второй элемент кортежа<br>  auto myTuple2 = Tuple!(int, string)(56, "Privet"); // используем конструктор типа<br>  writeln(myTuple2);<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Tuple!(int, string)(42, "Hello")<br>42<br>Hello<br>Tuple!(int, string)(56, "Privet")<br></code><br>При создании кортежа есть возможность дать его элементам имя для того, чтобы впоследствии можно было бы обращаться к ним по имени, а не по индексу. Имена можно задавать только путем указания их в конструкторе после каждого из типов.<br>Делается это следующим образом:<br><code class="language-d"><br>import std.stdio;<br>import std.typecons;<br>void main()<br>{<br>  auto myTuple2 = Tuple!(int, "number", string, "mytext")(56, "Privet");<br>  writeln(myTuple2.number);<br>  writeln(myTuple2.mytext);<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>56<br>Privet<br></code><br>Часто кортежи используются для того, чтобы вернуть из функции сразу несколько значений.<br>Пример:<br><code class="language-d"><br>import std.stdio;<br>import std.typecons;<br>void main()<br>{<br>  auto result = foo();<br>  writeln(result);<br>}<br><br>auto foo()<br>{<br>  int a = 2;<br>  int b = 3;<br>  string c = "ccc";<br>  // ...<br>  auto myTuple = tuple(a,b,c); <br>  return myTuple;<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Tuple!(int, int, string)(2, 3, "ccc")<br></code><br></div ><br></div ><br></div ><br></div ><br><div id="620bf959" class="bookcontent"><h1>#Глава 2</h1><div id="580dbd37" class="bookcontent"><h2>##Объектно Ориентированное Программирование</h2><div id="b7f1e997" class="bookcontent"><h3>###Классы</h3>В предыдущей главе мы уже немного касались темы ООП. Сейчас мы рассмотрим ее более подробно. <br>Главной задачей ООП является упростить разработку больших и сверхбольших проектов. ООП само по себе не является серебряной пулей и его применение не всегда бывает полезно. Поэтому D не навязывает эту концепцию как единственно правильную. Если сильно захотеть, то можно писать программы вообще без ООП или с его частичным применением.<br>Строго говоря, код у программиста - лишь побочный продукт. Чем его меньше, тем лучше. Главная задача состоит в решение проблем, а уж как эти проблемы будут решаться - зависит от каждого конкретного случая. D не поощряет написание классов где нужно и не нужно, как это делает Java и C#. Напротив, D позволяет не писать их попусту, тем самым значительно сокращая код и упрощая его поддержку.<br>В предыдущей главе мы уже косвенно затрагивали тему классов и экземпляров классов. <br>По своей сути класс - это шаблон реального объекта, а экземпляр - сам реальный объект, с которым идет работа. Каждый класс включает в себя набор полей и методов для работы с ними (функции, расположенные внутри класса, принято называть методами). Не стоит забывать, что многие функции в D не являются членами какого-либо класса. Такие функции называются просто функциями.<br>Важно понимать, что класс является лишь шаблоном. Каждый раз, когда мы будем выполнять какое-либо действие, мы будем работать с так называемым экземпляром класса. <br>Гораздо проще эту концепцию показать на примере.<br>Класс выглядит следующим образом:<br><code class="language-d"><br>            +--------------------------------+ ключевое слово, обозначающее класс (шаблон класса)<br>            v<br>          class MyClass &lt;--------------------+ имя класса<br>          {<br>     +---&gt;  string mydata; &lt;-----------------+ поле класса, которое мы инициализируем ниже<br>     |<br>     |      this(string mydata) &lt;------------+ данные, которые мы принимаем из конструктора класса<br>     |      {<br>     +-----+  this.mydata = mydata; &lt;-------+ присваиваем полю класса данные из конструктора<br>            }<br>            void sayHello(string name) &lt;------+ функция, расположенная внутри класса, называется методом<br>            {<br>              writeln("Hello, ", name);<br>            }<br>            // выполняем действия над mydata <br>          }<br></code><br>Итак, мы описали наш первый класс. В нем находится одно поле <code class="inlineCodeBlock">mydata</code> и один метод <code class="inlineCodeBlock">sayHello()</code>, принимающий текстовую строку. Конструкция `this( ... )` называется конструктором класса. Она обычно принимает при создании класса какие-то данные и на основе этих данных производит инициализацию полей. Внутри самого конструктора <code class="inlineCodeBlock">.this</code> используется для устанения неоднозначности в случае, если входные данные и поле класса имеют одинаковые имена.<br>Для того чтобы классом можно было пользоваться, его нужно реализовать. Т.е. создать его экземпляр, который будет иметь точно такую же структуру ,как и оригинальный класс, но в отличие от шаблона класса его поля уже будут инициализированы данными. Экземпляров класса может быть столько, сколько потребуется. Если вы создали базовый класс Человек, то вы можете создать два производных объекта и назвать их Мужчина и Женщина.<br>По своей создание экземпляра класса очень просто. Оно сводится лишь к передаче в конструктор требуемых для работы класса данных. В данном случае наш конструктор принимает лишь текстовую строку.<br>Создание экземпляра класса выглядит следующим образом:<br><code class="language-d"><br>    +-------------------------------------- Тип класса (у типа класса первая буква всегда должна быть заглавной)<br>    |<br>    |      +------------------------------- Имя экземпляра класса (всегда начинается со строковой)<br>    |      |<br>    v      v<br>MyClass myClass = new MyClass("some data");<br>                   ^              ^<br>                   |              +-------- Данные, которыми мы инициализируем поля класса<br>                   |<br>                   +----------------------- Ключевое слово new создает экземпляр класса, инициализируя его данными из конструктора<br></code><br>По умолчанию поля класса являются публичными, но прямой доступ к ним выполнять крайне не рекомендуется.<br>Следует отметить, что далеко не обязательно поля класса должны инициализироваться из конструктора. Они так же могут инициализироваться из методов класса.<br>Все классы в D имеют ссылочную структуру, т.е. если мы отправляем данные в класс, мы отправляем туда копию данных, но при этом мы не создаем копию класса. Экземпляр лишь ссылается на базовый класс. Ключевое слово <code class="inlineCodeBlock">new</code> служит именно этой задаче. Оно возвращает в экземпляр класса ссылку на базовый класс, а так же выделяет память для полей и методов.<br>Теперь, когда экземпляр класса создан, мы можем вызывать его методы для выполнения каких-то своих задач. Вызов метода состоит из указания имени экземпляра класса и имени самого метода.<br>Пример:<br><code class="language-d"><br>myclass.sayHello("David");<br></code><br>Т.к. наш метод тоже принимает какие-то данные в себя, то мы должны их туда отправить. Если мы этого не сделаем, то компилятор выругается: `Error: function app.MyClass.sayHello (string name) is not callable using argument types ()`. Так же он выругается, если мы передадим туда типы данных, которые он не ожидает. Пример:<br><code class="language-d"><br>myclass.sayHello(123, "David");<br></code><br>Результат:<br><code class="language-d"><br>Error: function app.MyClass.sayHello (string name) is not callable using argument types (int, string)<br></code><br>В данном случае компилятор говорит нам о том, что он ожидает лишь один параметр <code class="inlineCodeBlock">name</code> с типом <code class="inlineCodeBlock">string</code>, а мы передаем туда два параметра <code class="inlineCodeBlock">int</code> и <code class="inlineCodeBlock">string</code>.<br><br>Давайте теперь посмотрим на то, как будет выглядеть законченная версия нашего приложения:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  MyClass myClass = new MyClass("some data");<br>  myclass.sayHello("David");<br>}<br>class MyClass<br>{<br>  string mydata;<br>  this(string mydata)<br>  {<br>    mydata = this.mydata;<br>  }<br>  void sayHello(string name)<br>  {<br>    writeln("Hello, ", name);<br>  }<br>  // выполняем действия над mydata<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Hello, David<br></code><br>Теперь, если нам потребуется, мы можем передавать в наш метод <code class="inlineCodeBlock">sayHello</code> любые данные.<br>Пример:<br><code class="language-d"><br>...<br>  myclass.sayHello("David");<br>  myclass.sayHello("Jow");<br>  myclass.sayHello("Mike");<br>...<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Hello, David<br>Hello, Jow<br>Hello, Mike<br></code><br></div ><br><div id="3e3286d6" class="bookcontent"><h3>###Структуры</h3><br>Задолго до того, как появилось ООП, в чистом Си появилось такие понятие как структуры. Структура представляет из себя некий контейнер, который так же как и сейчас объект может включать в себя поля с данными и методы работы с ними. Впоследствии, когда стала формироваться концепция ООП, от структур решено было не отказываться, т.к. их использование в ряде случаев оказалось весьма удобно. Но, не смотря на то, что в ряде случаем они могут быть взаимозаменяемыми, между ними есть существенные отличия.<br>1. Структуры не поддерживают наследования<br>2. Объекты - ссылочный тип, а структуры - знаковый<br>3. Экземпляры класса создаются в куче, а структуры - в стеке<br>Данные правила кроме первого не являются законом. Если требуется, то можно не только передавать структуры по ссылке, но и размещать их в куче (используя ключевое слово <code class="inlineCodeBlock">new</code>). Однако эти вопросы уходят очень глубоко в системное программирование и особенности работы ЭВМ.<br>Пример объявления структуры:<br><code class="language-d"><br>struct MyStruct // &lt;-- имя структуры<br>{<br>  string name; // &lt;-- поле структуры<br>  int age; // ..<br>  string job; // ..<br>}<br></code><br>Теперь для того, чтобы начать работать со структурой, необходимо создать переменную с типом этой структуры. И заполнить его данными:<br><code class="language-d"><br>MyStruct mystruct; // создаем переменную mystruct с типом MyStruct<br>mystruct.name = "David";<br>mystruct.age = 20;<br>mystruct.job = "engineer";<br></code><br>Полный код:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  MyStruct mystruct; // создаем переменную mystruct с типом MyStruct<br>  mystruct.name = "David";<br>  mystruct.age = 20;<br>  mystruct.job = "engineer";<br>  writeln(mystruct.name);<br>  writeln(mystruct.age);<br>  writeln(mystruct.job);<br>  writeln(mystruct); // выводим структуру структуры<br>}<br>struct MyStruct // &lt;-- имя структуры<br>{<br>  string name; // &lt;-- поля структуры<br>  int age; // ..<br>  string job; // ..<br>}<br></code><br></div ><br><div id="5638ce1c" class="bookcontent"><h3>###Наследование</h3><br>Наследование позволяет избежать дублирования кода в проекте. Оно представляет из себя способ обобщить некоторые методы, которые могут быть общими сразу в нескольких классах. К примеру, если у нас в проекте есть потребность в двух классах - в мужчине и женщине, мы можем найти между ними ряд общих моментов. К примеру, и тот и другой умеют говорить, т.е. в них должен быть реализован метод <code class="inlineCodeBlock">talk</code>. Можно было бы конечно реализовать данный метод в каждом отдельном экземпляре, но тогда если у нас возникла бы потребность в нем исправить, к примеру "Hello" на "Goodbye", то правку пришлось бы делать сразу в двух местах.<br>Давайте для начала создадим базовый класс Человек:<br><code class="language-d"><br>class HumanClass<br>{<br>  string name;<br>  this(string name)<br>  {<br>    this.name = name;<br>  }<br>  void talk()<br>  {<br>    writeln("Hello");<br>  }<br>}<br></code><br>Наследование выглядит следующим образом. В начале вы пишите имя наследника, а потом класс, от которого хотите произвести наследование `class SubClass : MainClass`.<br>После чего класс потомок получает набор полей класса и методов от родителя. И далее в самом потомке вы можете реализовать уже его собственные методы.<br>При создании производных от базового класса классов в каждом из них требуется вызывать конструктор базового класса. За инициализацию базового конструктора отвечает слово <code class="inlineCodeBlock">super</code>. Пример:<br><code class="language-d"><br>  this(string name)<br>    {<br>      super(name);<br>    } <br></code><br>Полный пример:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  ManClass manClass = new ManClass("Adam", 21); // создаем экземпляр класса Мужчины<br>  //1. Выделится память в куче нужного размера<br>  //2. Вызовется конструктор ManClass.this(string name)<br>  //2.1. Вызовется HumanClass.this(string name), потому что написано super()<br>  WomanClass womanClass = new WomanClass("Eva"); // возраст Евы не определен и мы не передаем его в конструктор<br>  // создаем экземпляр класса Женщины<br>  manClass.talk(); // оба экземпляра класса умеют говорить<br>  womanClass.talk(); // оба экземпляра класса умеют говорить<br>  manClass.job(); // женщина умеет готовить<br>  womanClass.cook();<br>}<br>class HumanClass<br>{<br>  string name;<br>  this(string name)<br>  {<br>    this.name = name;<br>  }<br>  void talk()<br>  {<br>    writeln("Hello, ", name );<br>  }<br>}<br><br>class ManClass : HumanClass<br>{<br>  <br>  string name;<br>  int age;<br>  this(string name, int age)<br>  {<br>      super(name); // вызываем конструктор базового класса<br>      this.age = age; // конструктор текущего класса<br>  }<br>  void job()<br>  {<br>    writeln("Man doing job");<br>  }<br>}<br>class WomanClass : HumanClass<br>{<br>  string name;<br>  this(string name) <br>  {<br>      super(name); // вызываем конструктор базового класса<br>  } <br>  void cook()<br>  {<br>    writeln("Woman doing cooking");<br>  }<br>}<br></code><br></div ><br><div id="461106ed" class="bookcontent"><h3>###Интерфейсы</h3><br>В некоторых случаях удобно работать не с конкретными классами, а с некоторой абстракцией над ними. Предположим у нас есть приложение работающее с двумя базами данных MySQL и PostgreSQL. В приложении есть два класса для работы с каждой из баз данных. Однако если мы будем использовать конкретные имена классов и конкретные их реализации, то это может быть не всегда удобно. К примеру, если нам захочется добавить в код третью базу данных SQLite, то нам придется переделать очень много логики работы приложения.<br>Для того чтобы это все как-то обобщить и создать некоторую абстракцию над похожими классами были придуманы так называемые интерфейсы. К примеру если у нас есть классы <code class="inlineCodeBlock">MySQL</code> и <code class="inlineCodeBlock">PostgreSQL</code>, и это классы для работы с конкретными базами данных, то наш интерфейс будет стоять уровнем абстракции выше т.е. будет работать с какой-то абстрактной базой данных.<br>Интерфейс похож на класс, в котором методы объявлены, но не реализованы. Чтобы было понятнее давайте в начале рассмотрим пример.<br>Вот так создается интерфейс:<br><code class="language-d"><br>interface IDatabase<br>{<br>  void getData();<br>  void insertData();<br>}<br></code><br>А вот так класс:<br><code class="language-d"><br>class MySQL<br>{<br>  void getData()<br>  {<br>    // тут описывается логика чтения данных<br>  }<br>  void insertData()<br>  {<br>  // тут описывается логика вставки данных<br>  }<br>}<br></code><br>Обратите внимание на три момента.<br>1. Интерфейс это более высокий уровень абстракции чем класс, поэтому если наш класс называется по имени базы данных с которой он работает, то интерфейс у нас будет называться просто <code class="inlineCodeBlock">IDatabase</code>.<br>2. Методы в интерфейсе объявлены, но не реализованы т.е. у них нет тела. Для краткости в примере с классом мы тоже не реализовали в них логику, но она там должна быть.<br>3. Чтобы программист мог отличить класс от интерфейса по имени перед названием интерфейса всегда ставится заглавная буквы I.<br>После того как интерфейс создан нам необходимо:<br>1. Унаследоваться от него<br>2. Реализовать в производном от него классе все методы. Имена методов и тип возвращаемого значения должны совпадать, иначе произойдет ошибка компиляции.<br>Вот так будет выглядеть реализация интерфейса для классов <code class="inlineCodeBlock">MySQL</code> и <code class="inlineCodeBlock">PostgreSQL</code>: <br><code class="language-d"><br>interface IDatabase<br>{<br>  void getData();<br>  void insertData();<br>}<br>class MySQL : IDatabase<br>{<br>  void getData()<br>  {<br>  }<br>  void insertData()<br>  {<br>  }<br>}<br>class PostgreSQL : IDatabase<br>{<br>  void getData()<br>  {<br>  }<br>  void insertData()<br>  {<br>    <br>  }<br>}<br></code><br>Разумеется в данном примере мы могли бы обойтись без интерфейса, но в данном случае интерфейс гарантирует, что имена методов и типы данных которые они возвращают будут 100% совпадать т.е. не возникнет такой ситуации когда для выборки данных из MySQL метод будет называться <code class="inlineCodeBlock">getData</code>, а для PostgreSQL <code class="inlineCodeBlock">getDBData</code>.<br>Интерфейсы полезны там где:<br>1. Несколько классов имеет набор одинаковых методов. К примеру у нас есть 5 классов каждый для работы с изображениями отдельного типа (png, jpg, webp, ...) и у всех них будут методы: открыть, сохранить, сжать и тд.<br>2. Вы хотите работать с абстракцией, а не с конкретной реализацией. Это позволяет леко менять конкретную реализацию не ломая остальной код.<br>3. Заменять один класс другим не трогая все приложение<br>4. Проектировать логику приложений на интерфейсах, оставив реализацию на потом и применяя заглушки<br>5. Применять так называемое множественное наследование.<br>По большей части интерфейсы очень удобны, однако они не панацея. Унифицировать работу с теми же БД можно далеко не во всех случаях. Так практически невозможно написать *нормальный* драйвер который представлял бы одинаковые интерфейсы для хотя бы MySQL и PostgreSQL т.к. любая унификация будет приводить к ограничениям. Однако если вам нужно просто абстрагироваться от того в какой тип БД вы вставляете данные, то интерфейсы могут быть крайне полезны.<br>В следующем примере мы рассмотрим один из паттерном проектирования под названием "Фабрика", который более наглядный пример того где именно могут быть полезны интерфейсы. Суть фабрики заключается в том, что специальный "фабричный" класс будет создавать и возвращать экземпляр класса того или иного типа в зависимости от определенного условия. То есть если мы передадим туда, к примеру, "mysql", то он создаст и вернет нам экземпляр для работы с MySQL, если с PostgreSQL то экземпляр для работы с PostgreSQL.<br>Пример:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  Factory fc = new Factory(); // создаем экземпляр фабричного метода<br>  IDatabase dataBase = fc.getDbType("pg"); // возвращаем из фабрики экземпляр класса с которым мы работаем в данный момент<br>  if(dataBase !is null)<br>    dataBase.getData( ... ) // получаем данные из какой-то уже абстрактной БД<br>  else<br>    writeln("Unknow DB"); // фабрика вернула вместо экземпляра null<br>}<br>interface IDatabase<br>{<br>  void getData();<br>  void insertData();<br>}<br>class MySQL : IDatabase<br>{<br>  void getData()<br>  {<br>  }<br>  void insertData()<br>  {<br>  }<br>}<br><br>class PostgreSQL : IDatabase<br>{<br>  void getData()<br>  {<br>  }<br>  void insertData()<br>  {<br>    <br>  }<br>}<br>class Factory<br>{<br>  IDatabase getDbType(string dbname)<br>  {<br>    if(dbname == "pg")<br>      return new PostgreSQL(); // создаем экземпляр класс работы с PostgreSQL<br>    if(dbname == "mysql")<br>      return new MySQL(); // создаем экземпляр класс работы с MySQL<br>    else<br>      return null; // неизвестный тип БД<br>  }<br>}<br></code><br>Теперь у нас есть возможность менять тип БД с которой мы работаем не меняя самого кода.<br><br></div ><br><div id="d08d94a9" class="bookcontent"><h3>###Абстрактные методы и абстрактные классы</h3><br>Бывают ситуации, когда класс может содержать в себе как реализованные методы, так и их объявление (такое, которое содержится в интерфейсах). Если в классе есть хотя бы один незавершенный метод, то такой класс называется абстрактным. Объявление подобного метода начинается со слова <code class="inlineCodeBlock">abstract</code>.<br>Класс так же может быть объявлен с ключевым словом <code class="inlineCodeBlock">abstract</code>. Экземпляр подобного класса можно создать только унаследовавшись от него.<br>При реализации в производном классе такой класс должен быть перегружен оператором <code class="inlineCodeBlock">override</code>.<br>Пример:<br><code class="language-d"><br>import std.stdio;<br>void main()<br>{<br>  ManClass manClass = new ManClass("David");<br>  manClass.talk(); // вызываем завершенный метод<br>  manClass.sayHello("Jow"); // в начале реализуем, а потом вызываем<br>}<br>class Human <br>{<br>  abstract void sayHello(string name); // метод не завершен и его нужно реализовать<br>  void talk() // метод завершен и его можно только вызывать<br>  {<br>    writeln("I can talk");<br>  }<br>}<br>class ManClass : Human<br>{<br>  string name;<br>  this(string name)<br>  {<br>    this.name = name;<br>  }<br>  override void sayHello(string somename)<br>  {<br>    writeln("Hello, ", somename);<br>  }<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>I can talk<br>Hello, Jow<br></code><br></div ><br><div id="990669c7" class="bookcontent"><h3>###Шаблоные функции</h3>Шаблонные функции (templates) позволяют компилятору автоматически генерировать код в зависимости от того, какой тип данных передается в функцию. Значительно количество функций в D выполнено в виде шаблонов.<br>Простая функция на вход может принять только один (указанный в ее аргументах) тип данных. К примеру:<br><code class="language-d"><br>void foo(int x)<br>{<br>}<br></code><br>Бывают нужно, чтобы одна функция могла принимать на вход различные типы данных. К примеру, функция <code class="inlineCodeBlock">writeln()</code> может принимать как числа, так и строки.<br>Если требуется, мы можем выполнить перегрузку функции, описав ее с тем же именем, но другими входящими аргументами, к примеру:<br><code class="language-d"><br>void foo(string x)<br>{<br>}<br></code><br>Но зачастую это крайне неудобно, т.к. раздувает код и усложняет его поддержку.<br>....<br></div ><br></div ><br><div id="8e8d1158" class="bookcontent"><h2>##Многозадачность </h2><div id="826fad4b" class="bookcontent"><h3>###Потоки и файберы</h3><br>Изначально процессор занимается последовательным выполнением поступающих в него команд и ничего не знает ни о процессах, ни о потоках. Для того, чтобы мы могли работать с несколькими приложениями одновременно операционная система реализует для нас механизм многозадачности. <br>Его идея крайне простая - заставить каждое приложение думать, что на процессоре в настоящий момент запущено только оно одно. Но при этом каждому отдельному приложению давать доступ к процессору лишь на очень небольшой квант времени, после чего выполнять операцию переключение контекста т.е. брать полный слепок текущего состояния процессора, сохранять его в оперативной памяти и загружать на процессор данные нового приложения. За счет того, что переключение между процессами происходит очень быстро, пользователю кажется, что все приложения на компьютере выполняются одновременно.<br>Главную сложность в многопоточном программировании представляет из себя работа с разделяемыми данными т.е. такими данными, которые может модифицировать сразу несколько потоков. Однако с точки зрения программиста самый удобный код это код который исполняется линейно и последовательно. Как только эта линейность нарушается в программах начинает появляться большое количество различных ошибок.<br>Именно поэтому первым типом многозадачности была кооперативная многозадачность. Ее идея была в следующем - давать каждому приложению использовать процессор столько времени сколько потребуется, после чего каждое приложение должно было самостоятельно передать управление другому приложению. Однако любая ошибка в приложении или даже задержка при обращении к каким-либо данным приводили к тому, что приложение не передавало управление процессором дальше и с точки зрения пользователя это выглядело как зависание системы.<br>Поэтому очень скоро от этой практики решено было оказаться и задачу по переключению приложений возложили на операционную систему. Такой тип многозадачности был назван вытесняющим. Вот тут то уже переключение контекста происходило через определенный квант времени. Однако и этот подход имел свои недостатки.<br>Переключение контекста является достаточно времязатратной операцией т.к. требует не только сохранения состояния целого ряда регистров, но и обращения к оперативной памяти, которая в несколько раз медленее, чем регистры и кэш CPU.<br>Если на процессоре исполняется лишь несколько приложений, то это не приводит к заметным просадкам производительности, но с ростом количества одновременно исполняемых задач все больше и больше времени будет уходить исключительно на саму операцию переключение контекста в результате, к примеру, если у вас будет запущено 1000 потоков, то 90% времени будет уходить исключительно на переключение между ними.<br>Но это еще не все. Не все потоки выполняют на процессоре какие-либо вычисления. К примеру если вы пишете веб-сервер, то большая часть времени у потока будет уходить на ожидание ответа от базы данных или файловой системы, а значит поток все это время будет простаивать.<br>В случае с десктопными приложениями подобная проблема возникает крайне редко, но для сетевых приложений ситуация иная. Большинство веб-серверов обслуживает обслуживает сотни и тысячи подключений одновременно. Это значит, что каждое новое подключение мало того, что будет требовать создание нового потока обработки, так еще и сам поток будет 90% времени заниматься ожиданием.<br>Для решения этой проблемы в D была введена концепция файберов (fibers). Файберы представляют из себя потоки, работающие поверх системных потоков в юзерспейсе и при этом самостоятельно управляющие временем своей жизни. Идея была в следующем.<br>Если системные потоки стоят крайне дорого и временем их жизни управлять крайне сложно (хотя и можно), то файберы должны взять на себя все блокирующие операции т.е. такие операции которые не требуют каких-либо рассчетов, а большую часть времени у них ухдит на ожидание ввода-вывода (обычно это файловая система и база данных).<br>В задачу файбера входит лишь какая-то операция к примеру отправить запрос на сетевое устройство и не дожидаясь ответа передать управление другому файберу.<br>Вы можете спросить, но как определить какие операции являются блокирующими, а какие нет. Ведь с практической точки зрения любой рассчет на CPU будет точно таким же блокирующим т.к. без его выполнения невозможно продолжить дальнейшую работу.<br>Это действительно так и грань между тем где лучше использовать файберы, а где системные потоки является очень тонкой. Однако главное правило заключается в том, что **любые рассчетные операции следует производить в системных потоках**, а **любые операции которые требуют ожидания завершения операции ввода-вывода в файберах**.<br>Тут следует отметить, что Файберы это библиотечная функция и конкретная их реализация зависит исключительно от того какой именно библиотекой вы пользуетесь. В настоящий момент в D есть две реализации файберов. Первая в стандартной библиотеке Phobos, вторая в фреймворке vibed.<br>Для себя файберы проще всего представлять как функции, которые выполняются последовательно одна за другой. При этом у них отсутствют проблемы с общими данными и очередностью обращения к ним.<br>Все файберы встают на выполнение в очередь `event loop`, откуда они запускаются один за другим.<br>Но прежде чем говорить о файберах необходимо сказать несколько слов про итераторы и генераторы. Именно на идее генераторов и построена сама концепция файберов.<br>Если итератор ходит по некому контейнеру, содержимое которого уже посчитанно и лежит в памяти, то генератор представляют из себя диапазон (InputRange) который выплевывает из себя значения одно за другим, высчитывая следующее по каким-то правилам (при этом в памяти не хранит ни прошлые, ни следующие). При этом когда нам нужно пробежаться по какому-то диапазону значений и что-то с ними поделать - для нас нет разницы как они получены (из контейнера или из генератора). Поэтому там, где получается использовать генератор - это эффективно.<br>Для того, чтобы заставить генератор отдать значение используется ключевое слово <code class="inlineCodeBlock">yield</code>. <code class="inlineCodeBlock">yield</code> по своей сути очень похож на оператор <code class="inlineCodeBlock">return</code>, только в отличие от последнего <code class="inlineCodeBlock">yield</code> не выполняет выход из функции, а просто приостанавливает ее работу. <code class="inlineCodeBlock">yield</code> может использоваться только внутри файбера т.к. простые функции про файбер ничего не знают.<br>Пример создания файбера и передача ему в качестве аргумента вызываемой функции:<br><code class="language-d"><br>auto f = new Fiber(&foo);<br></code><br><code class="inlineCodeBlock">f.call();</code> вызов файбера<br><code class="inlineCodeBlock">Fiber.yield();</code> метод <code class="inlineCodeBlock">yield()</code> класса <code class="inlineCodeBlock">Fiber</code> вызывающий приостановку выполнение текущей функции<br>Пример:<br><code class="language-d"><br>import std.stdio;<br>import core.thread;<br>void main()<br>{<br>  auto f = new Fiber(&foo);<br>  f.call(); // Prints Hello<br>  f.call(); // Prints World<br>}<br>void foo()<br>{<br>  writeln("Hello");<br>  Fiber.yield();<br>  writeln("World");<br>}<br></code><br>Результат:<br><code class="language-d"><br>&gt; app.exe<br>Hello<br>World<br></code><br>Как видно из кода мы в начале создаем файбер передавая туда вызываемую функцию, потом запускаем его методом <code class="inlineCodeBlock">call</code>, потом прерываем выполнение данной функции <code class="inlineCodeBlock">Fiber.yield();</code> и затем снова делаем <code class="inlineCodeBlock">call</code> чтобы продолжить ее выполнение с того момента когда она остановилась.<br>Реализация файберов в <code class="inlineCodeBlock">vibed</code> очень похожа. И большинство функций во фреймворке автоматически выполняют <code class="inlineCodeBlock">yield</code> в процессе своей работы. <br>Пример асинхронной функции чтения файла:<br><code class="language-d"><br>  alias read = Stream.read;<br>  size_t read(scope ubyte[] dst, IOMode)<br>  {<br>    assert(this.readable);<br>    size_t len = dst.length;<br>    while (dst.length &gt; 0) {<br>      enforce(dst.length &lt;= leastSize);<br>      auto sz = min(dst.length, 4096);<br>      enforce(() @trusted { return .read(m_fileDescriptor, dst.ptr, cast(int)sz); } () == sz, "Failed to read data from disk.");<br>      dst = dst[sz .. $];<br>      m_ptr += sz;<br>      yield();<br>    }<br>    return len;<br>}<br></code><br><br><br></div></div></div><br>